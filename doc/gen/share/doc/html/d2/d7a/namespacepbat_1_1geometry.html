<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.13.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PhysicsBasedAnimationToolkit: pbat::geometry Namespace Reference</title>
  <link rel="icon" href="../../entei.icon.png" type="image/x-icon" />
  <link href="../../tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="../../jquery.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
  <!-- BEGIN Doxygen Awesome -->
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeTabs.init()
  </script>
  <!-- END Doxygen Awesome -->
  <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
  <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="../../pbat.svg"  /></td>
              <td id="projectalign">
                <div id="projectname">PhysicsBasedAnimationToolkit<span
                    id="projectnumber">&#160;0.0.10</span>
                </div>
                <div id="projectbrief">Cross-platform C++20 library of algorithms and data structures commonly used in computer graphics research on physically-based simulation.</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d7a/namespacepbat_1_1geometry.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pbat::geometry Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Geometric queries, quantities and data structures.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8a/namespacepbat_1_1geometry_1_1_closest_point_queries.html">ClosestPointQueries</a></td></tr>
<tr class="memdesc:dd/d8a/namespacepbat_1_1geometry_1_1_closest_point_queries"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains functions to answer closest point queries. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0f/namespacepbat_1_1geometry_1_1_distance_queries.html">DistanceQueries</a></td></tr>
<tr class="memdesc:d8/d0f/namespacepbat_1_1geometry_1_1_distance_queries"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains functions to answer distance queries. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da1/namespacepbat_1_1geometry_1_1_intersection_queries.html">IntersectionQueries</a></td></tr>
<tr class="memdesc:db/da1/namespacepbat_1_1geometry_1_1_intersection_queries"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains functions to answer intersection queries. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de7/namespacepbat_1_1geometry_1_1_overlap_queries.html">OverlapQueries</a></td></tr>
<tr class="memdesc:df/de7/namespacepbat_1_1geometry_1_1_overlap_queries"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains functions to answer overlap queries. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9d/namespacepbat_1_1geometry_1_1sdf.html">sdf</a></td></tr>
<tr class="memdesc:d2/d9d/namespacepbat_1_1geometry_1_1sdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for signed distance functions (SDFs) and related operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd2/classpbat_1_1geometry_1_1_aabb_kd_tree_hierarchy.html">AabbKdTreeHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned k-D tree hierarchy of axis-aligned bounding boxes.  <a href="../../d5/dd2/classpbat_1_1geometry_1_1_aabb_kd_tree_hierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d92/classpbat_1_1geometry_1_1_aabb_radix_tree_hierarchy.html">AabbRadixTreeHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned radix tree hierarchy of axis-aligned bounding boxes.  <a href="../../d5/d92/classpbat_1_1geometry_1_1_aabb_radix_tree_hierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/classpbat_1_1geometry_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned bounding box class.  <a href="../../d5/d2e/classpbat_1_1geometry_1_1_axis_aligned_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dda/classpbat_1_1geometry_1_1_bounding_volume_hierarchy.html">BoundingVolumeHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base class for BVHs.  <a href="../../df/dda/classpbat_1_1geometry_1_1_bounding_volume_hierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d29/classpbat_1_1geometry_1_1_hash_grid.html">HashGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/d29/classpbat_1_1geometry_1_1_hash_grid.html" title="HashGrid is a spatial partitioning data structure that divides 3D space into a sparse grid of cells,...">HashGrid</a> is a spatial partitioning data structure that divides 3D space into a sparse grid of cells, allowing for efficient querying of point neighbours within a certain region.  <a href="../../de/d29/classpbat_1_1geometry_1_1_hash_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8b/classpbat_1_1geometry_1_1_hierarchical_hash_grid.html">HierarchicalHashGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial partitioning data structure that divides 3D space into a set of sparse grids. Allowing for efficient querying of point neighbours within a certain region. Implements <a class="el" href="../../d0/de3/citelist.html#CITEREF_eitz2007hierarchical">[4]</a>.  <a href="../../d2/d8b/classpbat_1_1geometry_1_1_hierarchical_hash_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dd5/classpbat_1_1geometry_1_1_kd_tree.html">KdTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KDTree class.  <a href="../../da/dd5/classpbat_1_1geometry_1_1_kd_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d3f/structpbat_1_1geometry_1_1_kd_tree_node.html">KdTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node of a KDTree.  <a href="../../df/d3f/structpbat_1_1geometry_1_1_kd_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dca/classpbat_1_1geometry_1_1_tetrahedral_aabb_hierarchy.html">TetrahedralAabbHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tetrahedral AABB hierarchy class.  <a href="../../d9/dca/classpbat_1_1geometry_1_1_tetrahedral_aabb_hierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d76/classpbat_1_1geometry_1_1_triangle_aabb_hierarchy2_d.html">TriangleAabbHierarchy2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding volume hierarchy for triangles in 2D.  <a href="../../de/d76/classpbat_1_1geometry_1_1_triangle_aabb_hierarchy2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0c/classpbat_1_1geometry_1_1_triangle_aabb_hierarchy3_d.html">TriangleAabbHierarchy3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding volume hierarchy for triangles in 3D.  <a href="../../dc/d0c/classpbat_1_1geometry_1_1_triangle_aabb_hierarchy3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a930a1551ac51c87aae9dcd75f0163ee4" id="r_a930a1551ac51c87aae9dcd75f0163ee4"><td class="memItemLeft" align="right" valign="top"><a id="a930a1551ac51c87aae9dcd75f0163ee4" name="a930a1551ac51c87aae9dcd75f0163ee4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MortonCodeType</b> = std::uint32_t</td></tr>
<tr class="memdesc:a930a1551ac51c87aae9dcd75f0163ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent Morton codes. <br /></td></tr>
<tr class="separator:a930a1551ac51c87aae9dcd75f0163ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a103f60b89bb2f63e700913abafdda8b1" id="r_a103f60b89bb2f63e700913abafdda8b1"><td class="memTemplParams" colspan="2">template&lt;auto kDims, auto kClusterNodes, class FCluster, class TDerivedL, class TDerivedU&gt; </td></tr>
<tr class="memitem:a103f60b89bb2f63e700913abafdda8b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a103f60b89bb2f63e700913abafdda8b1">ClustersToAabbs</a> (FCluster fCluster, <a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a> nClusters, Eigen::DenseBase&lt; TDerivedL &gt; &amp;L, Eigen::DenseBase&lt; TDerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a103f60b89bb2f63e700913abafdda8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AABBs of nClusters kDims-dimensional point clusters.  <br /></td></tr>
<tr class="separator:a103f60b89bb2f63e700913abafdda8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256e078a7a2b4196b8a334682d47ef1e" id="r_a256e078a7a2b4196b8a334682d47ef1e"><td class="memTemplParams" colspan="2">template&lt;auto kDims, auto kClusterNodes, class FCluster, class TDerivedB&gt; </td></tr>
<tr class="memitem:a256e078a7a2b4196b8a334682d47ef1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a256e078a7a2b4196b8a334682d47ef1e">ClustersToAabbs</a> (FCluster fCluster, <a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a> nClusters, Eigen::DenseBase&lt; TDerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a256e078a7a2b4196b8a334682d47ef1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AABBs of nClusters kDims-dimensional point clusters.  <br /></td></tr>
<tr class="separator:a256e078a7a2b4196b8a334682d47ef1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42669e95233f6352ec38496fbc1d9256" id="r_a42669e95233f6352ec38496fbc1d9256"><td class="memTemplParams" colspan="2">template&lt;auto kDims, auto kElemNodes, class TDerivedX, class TDerivedE, class TDerivedL, class TDerivedU&gt; </td></tr>
<tr class="memitem:a42669e95233f6352ec38496fbc1d9256"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42669e95233f6352ec38496fbc1d9256">MeshToAabbs</a> (Eigen::DenseBase&lt; TDerivedX &gt; const &amp;X, Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, Eigen::DenseBase&lt; TDerivedL &gt; &amp;L, Eigen::DenseBase&lt; TDerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a42669e95233f6352ec38496fbc1d9256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AABBs of nElemNodes simplex mesh elements in kDims dimensions.  <br /></td></tr>
<tr class="separator:a42669e95233f6352ec38496fbc1d9256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5d222ddd9e4d2eb311482206330e8d" id="r_a3d5d222ddd9e4d2eb311482206330e8d"><td class="memTemplParams" colspan="2">template&lt;auto kDims, auto kElemNodes, class TDerivedX, class TDerivedE, class TDerivedB&gt; </td></tr>
<tr class="memitem:a3d5d222ddd9e4d2eb311482206330e8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d5d222ddd9e4d2eb311482206330e8d">MeshToAabbs</a> (Eigen::DenseBase&lt; TDerivedX &gt; const &amp;X, Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, Eigen::DenseBase&lt; TDerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a3d5d222ddd9e4d2eb311482206330e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes AABBs of nElemNodes simplex mesh elements in kDims dimensions.  <br /></td></tr>
<tr class="separator:a3d5d222ddd9e4d2eb311482206330e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661a99346d0d12bef33bed68330b9c51" id="r_a661a99346d0d12bef33bed68330b9c51"><td class="memTemplParams" colspan="2">template&lt;math::linalg::mini::CReadableVectorizedMatrix TP1T, math::linalg::mini::CReadableVectorizedMatrix TQ1T, math::linalg::mini::CReadableVectorizedMatrix TP2T, math::linalg::mini::CReadableVectorizedMatrix TQ2T, math::linalg::mini::CReadableVectorizedMatrix TP1, math::linalg::mini::CReadableVectorizedMatrix TQ1, math::linalg::mini::CReadableVectorizedMatrix TP2, math::linalg::mini::CReadableVectorizedMatrix TQ2, class TScalar = typename TP1T::ScalarType&gt; </td></tr>
<tr class="memitem:a661a99346d0d12bef33bed68330b9c51"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a661a99346d0d12bef33bed68330b9c51">EdgeEdgeCcd</a> (TP1T const &amp;P1T, TQ1T const &amp;Q1T, TP2T const &amp;P2T, TQ2T const &amp;Q2T, TP1 const &amp;P1, TQ1 const &amp;Q1, TP2 const &amp;P2, TQ2 const &amp;Q2) -&gt; <a class="el" href="../../d6/d9a/classpbat_1_1math_1_1linalg_1_1mini_1_1_s_matrix.html">math::linalg::mini::SVector</a>&lt; TScalar, 3 &gt;</td></tr>
<tr class="memdesc:a661a99346d0d12bef33bed68330b9c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time of impact \( t^* \) and barycentric coordinates \( \mathbf{\beta} \) of the intersection point between an edge \( (P1,Q1) \) and another edge \( (P2,Q2) \) moving along a linear trajectory.  <br /></td></tr>
<tr class="separator:a661a99346d0d12bef33bed68330b9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf105b6fa763e5397604209886043f1" id="r_aebf105b6fa763e5397604209886043f1"><td class="memTemplParams" colspan="2">template&lt;common::CIndex THashed&gt; </td></tr>
<tr class="memitem:aebf105b6fa763e5397604209886043f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebf105b6fa763e5397604209886043f1">HashByXorOfPrimeMultiples</a> ()</td></tr>
<tr class="memdesc:aebf105b6fa763e5397604209886043f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash function used in <a class="el" href="../../d0/de3/citelist.html#CITEREF_teschner2003">[13]</a> for 2 or 3-vectors suitable as input to <a class="el" href="../../de/d29/classpbat_1_1geometry_1_1_hash_grid.html" title="HashGrid is a spatial partitioning data structure that divides 3D space into a sparse grid of cells,...">HashGrid</a>'s API.  <br /></td></tr>
<tr class="separator:aebf105b6fa763e5397604209886043f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2139bf2b76ae61c75231843b82cc0dc8" id="r_a2139bf2b76ae61c75231843b82cc0dc8"><td class="memTemplParams" colspan="2">template&lt;common::CIndex TIndex = Index&gt; </td></tr>
<tr class="memitem:a2139bf2b76ae61c75231843b82cc0dc8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2139bf2b76ae61c75231843b82cc0dc8">SimplexMeshBoundary</a> (Eigen::Ref&lt; Eigen::Matrix&lt; TIndex, Eigen::Dynamic, Eigen::Dynamic &gt; const &gt; const &amp;C, TIndex n) -&gt; std::tuple&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;, Eigen::Matrix&lt; TIndex, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="memdesc:a2139bf2b76ae61c75231843b82cc0dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the boundary mesh of a simplex mesh.  <br /></td></tr>
<tr class="separator:a2139bf2b76ae61c75231843b82cc0dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4901d411d4efdcab87a01633da21026f" id="r_a4901d411d4efdcab87a01633da21026f"><td class="memItemLeft" align="right" valign="top">PBAT_HOST_DEVICE <a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4901d411d4efdcab87a01633da21026f">ExpandBits</a> (<a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a> v)</td></tr>
<tr class="memdesc:a4901d411d4efdcab87a01633da21026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands a 10-bit integer into 30 bits by inserting 2 zeros after each bit.  <br /></td></tr>
<tr class="separator:a4901d411d4efdcab87a01633da21026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad92bd1773247e0798ac5a5a6df79517" id="r_aad92bd1773247e0798ac5a5a6df79517"><td class="memTemplParams" colspan="2">template&lt;detail::CMorton3dPoint Point&gt; </td></tr>
<tr class="memitem:aad92bd1773247e0798ac5a5a6df79517"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE <a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad92bd1773247e0798ac5a5a6df79517">Morton3D</a> (Point x)</td></tr>
<tr class="memdesc:aad92bd1773247e0798ac5a5a6df79517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a 30-bit Morton code for the given 3D point located within the unit cube [0,1].  <br /></td></tr>
<tr class="separator:aad92bd1773247e0798ac5a5a6df79517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60fff88ac0003c731dc470d0ab27d4" id="r_a5d60fff88ac0003c731dc470d0ab27d4"><td class="memTemplParams" colspan="2">template&lt;math::linalg::mini::CReadableVectorizedMatrix TXT, math::linalg::mini::CReadableVectorizedMatrix TAT, math::linalg::mini::CReadableVectorizedMatrix TBT, math::linalg::mini::CReadableVectorizedMatrix TCT, math::linalg::mini::CReadableVectorizedMatrix TX, math::linalg::mini::CReadableVectorizedMatrix TA, math::linalg::mini::CReadableVectorizedMatrix TB, math::linalg::mini::CReadableVectorizedMatrix TC, class TScalar = typename TXT::ScalarType&gt; </td></tr>
<tr class="memitem:a5d60fff88ac0003c731dc470d0ab27d4"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d60fff88ac0003c731dc470d0ab27d4">PointTriangleCcd</a> (TXT const &amp;XT, TAT const &amp;AT, TBT const &amp;BT, TCT const &amp;CT, TX const &amp;X, TA const &amp;A, TB const &amp;B, TC const &amp;C) -&gt; <a class="el" href="../../d6/d9a/classpbat_1_1math_1_1linalg_1_1mini_1_1_s_matrix.html">math::linalg::mini::SVector</a>&lt; TScalar, 4 &gt;</td></tr>
<tr class="memdesc:a5d60fff88ac0003c731dc470d0ab27d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time of impact \( t^* \) and barycentric coordinates \( \mathbf{\beta} \) of the intersection point between a point and a triangle moving along a linear trajectory.  <br /></td></tr>
<tr class="separator:a5d60fff88ac0003c731dc470d0ab27d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf85fc0664ca1101efadc446fa8fc24" id="r_adcf85fc0664ca1101efadc446fa8fc24"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodeOverlap, class FObjectOverlap, class FOnFound, auto N = 2, class TIndex = Index, auto kStackDepth = 64&gt; </td></tr>
<tr class="memitem:adcf85fc0664ca1101efadc446fa8fc24"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcf85fc0664ca1101efadc446fa8fc24">Overlaps</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FNodeOverlap fNodeOverlaps, FObjectOverlap fObjectOverlaps, FOnFound fOnFound, TIndex root=0)</td></tr>
<tr class="memdesc:adcf85fc0664ca1101efadc446fa8fc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all nodes in a branch and bound tree that overlap with a given object.  <br /></td></tr>
<tr class="separator:adcf85fc0664ca1101efadc446fa8fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2eb6a69fb127bcd88f6f0b348a7e79" id="r_adc2eb6a69fb127bcd88f6f0b348a7e79"><td class="memTemplParams" colspan="2">template&lt;class FChildLhs, class FIsLeafLhs, class FLeafSizeLhs, class FLeafObjectLhs, class FChildRhs, class FIsLeafRhs, class FLeafSizeRhs, class FLeafObjectRhs, class FNodesOverlap, class FObjectsOverlap, class FOnFound, auto NLhs = 2, auto NRhs = 2, class TIndex = Index, auto kStackDepth = 128&gt; </td></tr>
<tr class="memitem:adc2eb6a69fb127bcd88f6f0b348a7e79"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc2eb6a69fb127bcd88f6f0b348a7e79">Overlaps</a> (FChildLhs fChildLhs, FIsLeafLhs fIsLeafLhs, FLeafSizeLhs fLeafSizeLhs, FLeafObjectLhs fLeafObjectLhs, FChildRhs fChildRhs, FIsLeafRhs fIsLeafRhs, FLeafSizeRhs fLeafSizeRhs, FLeafObjectRhs fLeafObjectRhs, FNodesOverlap fNodesOverlap, FObjectsOverlap fObjectsOverlap, FOnFound fOnFound, TIndex rootLhs=0, TIndex rootRhs=0)</td></tr>
<tr class="memdesc:adc2eb6a69fb127bcd88f6f0b348a7e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes overlaps between two branch and bound trees.  <br /></td></tr>
<tr class="separator:adc2eb6a69fb127bcd88f6f0b348a7e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad318504f4d24918e58f8f4780f384eaf" id="r_ad318504f4d24918e58f8f4780f384eaf"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodesOverlap, class FObjectsOverlap, class FOnFound, auto N = 2, class TIndex = Index, auto kStackDepth = 128&gt; </td></tr>
<tr class="memitem:ad318504f4d24918e58f8f4780f384eaf"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad318504f4d24918e58f8f4780f384eaf">SelfOverlaps</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FNodesOverlap fNodesOverlap, FObjectsOverlap fObjectsOverlap, FOnFound fOnFound, TIndex root=0)</td></tr>
<tr class="memdesc:ad318504f4d24918e58f8f4780f384eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute overlapping nodes from a branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:ad318504f4d24918e58f8f4780f384eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430221b7d21dd0e358c69c0dc6f7a176" id="r_a430221b7d21dd0e358c69c0dc6f7a176"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kStackDepth = 64, auto kQueueSize = 8&gt; </td></tr>
<tr class="memitem:a430221b7d21dd0e358c69c0dc6f7a176"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a430221b7d21dd0e358c69c0dc6f7a176">DfsAllNearestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, bool bUseBestFirstSearch=false, TScalar fUpper=std::numeric_limits&lt; TScalar &gt;::max(), TScalar eps=TScalar(0), TIndex root=0)</td></tr>
<tr class="memdesc:a430221b7d21dd0e358c69c0dc6f7a176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find distance minimizing objects in branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:a430221b7d21dd0e358c69c0dc6f7a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3e58b48638f69073cb5d0e200eb22" id="r_acde3e58b48638f69073cb5d0e200eb22"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </td></tr>
<tr class="memitem:acde3e58b48638f69073cb5d0e200eb22"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acde3e58b48638f69073cb5d0e200eb22">NearestToFurthestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, TScalar fUpper=std::numeric_limits&lt; TScalar &gt;::max(), TIndex root=0)</td></tr>
<tr class="memdesc:acde3e58b48638f69073cb5d0e200eb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse objects in a branch and bound tree rooted in root in increasing order of distance.  <br /></td></tr>
<tr class="separator:acde3e58b48638f69073cb5d0e200eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9a37efd1d0dbaca17409dfea8fd2ca" id="r_acf9a37efd1d0dbaca17409dfea8fd2ca"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </td></tr>
<tr class="memitem:acf9a37efd1d0dbaca17409dfea8fd2ca"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf9a37efd1d0dbaca17409dfea8fd2ca">AllNearestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, TScalar fUpper=std::numeric_limits&lt; TScalar &gt;::max(), TScalar eps=TScalar(0), TIndex root=0)</td></tr>
<tr class="memdesc:acf9a37efd1d0dbaca17409dfea8fd2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all global distance minimizers in a branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:acf9a37efd1d0dbaca17409dfea8fd2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367821018a940f7d4312b7473fde7516" id="r_a367821018a940f7d4312b7473fde7516"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </td></tr>
<tr class="memitem:a367821018a940f7d4312b7473fde7516"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a367821018a940f7d4312b7473fde7516">KNearestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, TIndex K, TScalar fUpper=std::numeric_limits&lt; TScalar &gt;::max(), TIndex root=0)</td></tr>
<tr class="memdesc:a367821018a940f7d4312b7473fde7516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the (sorted) K objects with the smallest distances in a branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:a367821018a940f7d4312b7473fde7516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655d0e68b688c36b5798f0eb6ddc59e5" id="r_a655d0e68b688c36b5798f0eb6ddc59e5"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodeOverlap, class FObjectOverlap, class FOnFound, auto N, class TIndex, auto kStackDepth&gt; </td></tr>
<tr class="memitem:a655d0e68b688c36b5798f0eb6ddc59e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a655d0e68b688c36b5798f0eb6ddc59e5">Overlaps</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FNodeOverlap fNodeOverlaps, FObjectOverlap fObjectOverlaps, FOnFound fOnFound, TIndex root)</td></tr>
<tr class="memdesc:a655d0e68b688c36b5798f0eb6ddc59e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all nodes in a branch and bound tree that overlap with a given object.  <br /></td></tr>
<tr class="separator:a655d0e68b688c36b5798f0eb6ddc59e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8bea434c41111fa827e7ddb4ec4b21" id="r_a1b8bea434c41111fa827e7ddb4ec4b21"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kStackDepth, auto kQueueSize&gt; </td></tr>
<tr class="memitem:a1b8bea434c41111fa827e7ddb4ec4b21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b8bea434c41111fa827e7ddb4ec4b21">DfsAllNearestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, bool bUseBestFirstSearch, TScalar fUpper, TScalar eps, TIndex root)</td></tr>
<tr class="memdesc:a1b8bea434c41111fa827e7ddb4ec4b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find distance minimizing objects in branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:a1b8bea434c41111fa827e7ddb4ec4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084206e1ce2988808849137dcb2e4a82" id="r_a084206e1ce2988808849137dcb2e4a82"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kHeapCapacity&gt; </td></tr>
<tr class="memitem:a084206e1ce2988808849137dcb2e4a82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a084206e1ce2988808849137dcb2e4a82">NearestToFurthestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, TScalar fUpper, TIndex root)</td></tr>
<tr class="memdesc:a084206e1ce2988808849137dcb2e4a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse objects in a branch and bound tree rooted in root in increasing order of distance.  <br /></td></tr>
<tr class="separator:a084206e1ce2988808849137dcb2e4a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e669110bf2be65b77669262845b8ca4" id="r_a5e669110bf2be65b77669262845b8ca4"><td class="memTemplParams" colspan="2">template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kHeapCapacity&gt; </td></tr>
<tr class="memitem:a5e669110bf2be65b77669262845b8ca4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e669110bf2be65b77669262845b8ca4">KNearestNeighbours</a> (FChild fChild, FIsLeaf fIsLeaf, FLeafSize fLeafSize, FLeafObject fLeafObject, FDistanceLowerBound fLower, FDistance fDistance, FOnFound fOnFound, TIndex K, TScalar fUpper, TIndex root)</td></tr>
<tr class="memdesc:a5e669110bf2be65b77669262845b8ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the (sorted) K objects with the smallest distances in a branch and bound tree rooted in root.  <br /></td></tr>
<tr class="separator:a5e669110bf2be65b77669262845b8ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Geometric queries, quantities and data structures. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acf9a37efd1d0dbaca17409dfea8fd2ca" name="acf9a37efd1d0dbaca17409dfea8fd2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9a37efd1d0dbaca17409dfea8fd2ca">&#9670;&#160;</a></span>AllNearestNeighbours()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::AllNearestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;TScalar&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TScalar(0)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all global distance minimizers in a branch and bound tree rooted in root. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kHeapCapacity</td><td>Maximum capacity of the min-distance-heap </td></tr>
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">eps</td><td>Epsilon to consider objects at the same distance </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a256e078a7a2b4196b8a334682d47ef1e" name="a256e078a7a2b4196b8a334682d47ef1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256e078a7a2b4196b8a334682d47ef1e">&#9670;&#160;</a></span>ClustersToAabbs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto kDims, auto kClusterNodes, class FCluster, class TDerivedB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::geometry::ClustersToAabbs </td>
          <td>(</td>
          <td class="paramtype">FCluster</td>          <td class="paramname"><span class="paramname"><em>fCluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a></td>          <td class="paramname"><span class="paramname"><em>nClusters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes AABBs of nClusters kDims-dimensional point clusters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kDims</td><td>Spatial dimension </td></tr>
    <tr><td class="paramname">kClusterNodes</td><td>Number of nodes in a cluster </td></tr>
    <tr><td class="paramname">FCluster</td><td>Function with signature <code>auto (<a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a>) -&gt; std::convertible_to&lt;<a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a>&lt;kDims, kClusterNodes&gt;&gt;</code> </td></tr>
    <tr><td class="paramname">TDerivedB</td><td>Eigen dense expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fCluster</td><td>Function to get the cluster at index <code>c</code> </td></tr>
    <tr><td class="paramname">nClusters</td><td>Number of clusters </td></tr>
    <tr><td class="paramname">B</td><td>2*kDims x |# clusters| output AABBs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103f60b89bb2f63e700913abafdda8b1" name="a103f60b89bb2f63e700913abafdda8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103f60b89bb2f63e700913abafdda8b1">&#9670;&#160;</a></span>ClustersToAabbs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto kDims, auto kClusterNodes, class FCluster, class TDerivedL, class TDerivedU&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::geometry::ClustersToAabbs </td>
          <td>(</td>
          <td class="paramtype">FCluster</td>          <td class="paramname"><span class="paramname"><em>fCluster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a></td>          <td class="paramname"><span class="paramname"><em>nClusters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedU &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>U</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes AABBs of nClusters kDims-dimensional point clusters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kDims</td><td>Spatial dimension </td></tr>
    <tr><td class="paramname">kClusterNodes</td><td>Number of nodes in a cluster </td></tr>
    <tr><td class="paramname">FCluster</td><td>Function with signature <code>auto (<a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a>) -&gt; std::convertible_to&lt;<a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a>&lt;kDims, kClusterNodes&gt;&gt;</code> </td></tr>
    <tr><td class="paramname">TDerivedL</td><td>Eigen dense expression type </td></tr>
    <tr><td class="paramname">TDerivedU</td><td>Eigen dense expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fCluster</td><td>Function to get the cluster at index <code>c</code> </td></tr>
    <tr><td class="paramname">nClusters</td><td>Number of clusters </td></tr>
    <tr><td class="paramname">L</td><td>kDims x |# clusters| output AABBs lower bounds </td></tr>
    <tr><td class="paramname">U</td><td>kDims x |# clusters| output AABBs upper bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8bea434c41111fa827e7ddb4ec4b21" name="a1b8bea434c41111fa827e7ddb4ec4b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8bea434c41111fa827e7ddb4ec4b21">&#9670;&#160;</a></span>DfsAllNearestNeighbours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kStackDepth, auto kQueueSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pbat::geometry::DfsAllNearestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUseBestFirstSearch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TScalar(0)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find distance minimizing objects in branch and bound tree rooted in root. </p>
<dl class="section note"><dt>Note</dt><dd>Although it's possible to obtain nearest neighbour(s) using the KNearestNeighbours function, we also expose this function which focuses on finding the distance minimizer. Both functions are branch and bound tree traversal algorithms. This function exposes 2 variants of the traversal:<ol type="1">
<li>Pre-order traversal: This is the default traversal method. It visits the children of a node in the order they are stored in the branch and bound tree, i.e. natural order, or random order, using depth-first search. This has the advantage of using fewer CPU-cycles per node visit, but might require more visits than a guided traversal.</li>
<li>Best-first search: This is an alternative traversal method. At each node, it sorts the children by their lower bounds and visits them in that order. The sort costs non-trivially more stack memory and CPU cycles, but might require fewer visits than a natural order depth-first traversal.</li>
</ol>
</dd>
<dd>
Another approach for tweaking the performance of the NN search is to provide a tight initial upper bound fUpper, which will help prune most of the search space.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
    <tr><td class="paramname">kQueueSize</td><td>Maximum size of the nearest neighbour queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">bUseBestFirstSearch</td><td>Use best-first search instead of pre-order traversal </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">eps</td><td>Epsilon to consider objects at the same distance </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a430221b7d21dd0e358c69c0dc6f7a176" name="a430221b7d21dd0e358c69c0dc6f7a176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430221b7d21dd0e358c69c0dc6f7a176">&#9670;&#160;</a></span>DfsAllNearestNeighbours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kStackDepth = 64, auto kQueueSize = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::DfsAllNearestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUseBestFirstSearch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>eps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TScalar(0)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find distance minimizing objects in branch and bound tree rooted in root. </p>
<dl class="section note"><dt>Note</dt><dd>Although it's possible to obtain nearest neighbour(s) using the KNearestNeighbours function, we also expose this function which focuses on finding the distance minimizer. Both functions are branch and bound tree traversal algorithms. This function exposes 2 variants of the traversal:<ol type="1">
<li>Pre-order traversal: This is the default traversal method. It visits the children of a node in the order they are stored in the branch and bound tree, i.e. natural order, or random order, using depth-first search. This has the advantage of using fewer CPU-cycles per node visit, but might require more visits than a guided traversal.</li>
<li>Best-first search: This is an alternative traversal method. At each node, it sorts the children by their lower bounds and visits them in that order. The sort costs non-trivially more stack memory and CPU cycles, but might require fewer visits than a natural order depth-first traversal.</li>
</ol>
</dd>
<dd>
Another approach for tweaking the performance of the NN search is to provide a tight initial upper bound fUpper, which will help prune most of the search space.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
    <tr><td class="paramname">kQueueSize</td><td>Maximum size of the nearest neighbour queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">bUseBestFirstSearch</td><td>Use best-first search instead of pre-order traversal </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">eps</td><td>Epsilon to consider objects at the same distance </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a661a99346d0d12bef33bed68330b9c51" name="a661a99346d0d12bef33bed68330b9c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661a99346d0d12bef33bed68330b9c51">&#9670;&#160;</a></span>EdgeEdgeCcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;math::linalg::mini::CReadableVectorizedMatrix TP1T, math::linalg::mini::CReadableVectorizedMatrix TQ1T, math::linalg::mini::CReadableVectorizedMatrix TP2T, math::linalg::mini::CReadableVectorizedMatrix TQ2T, math::linalg::mini::CReadableVectorizedMatrix TP1, math::linalg::mini::CReadableVectorizedMatrix TQ1, math::linalg::mini::CReadableVectorizedMatrix TP2, math::linalg::mini::CReadableVectorizedMatrix TQ2, class TScalar = typename TP1T::ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE auto pbat::geometry::EdgeEdgeCcd </td>
          <td>(</td>
          <td class="paramtype">TP1T const &amp;</td>          <td class="paramname"><span class="paramname"><em>P1T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TQ1T const &amp;</td>          <td class="paramname"><span class="paramname"><em>Q1T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TP2T const &amp;</td>          <td class="paramname"><span class="paramname"><em>P2T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TQ2T const &amp;</td>          <td class="paramname"><span class="paramname"><em>Q2T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TP1 const &amp;</td>          <td class="paramname"><span class="paramname"><em>P1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TQ1 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TP2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>P2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TQ2 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Q2</em></span>&#160;) -&gt; <a class="el" href="../../d6/d9a/classpbat_1_1math_1_1linalg_1_1mini_1_1_s_matrix.html">math::linalg::mini::SVector</a>&lt;TScalar, 3&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time of impact \( t^* \) and barycentric coordinates \( \mathbf{\beta} \) of the intersection point between an edge \( (P1,Q1) \) and another edge \( (P2,Q2) \) moving along a linear trajectory. </p>
<p>Solves for inexact roots (if any) in the range [0,1] of the polynomial   </p><p class="formulaDsp">
\[\langle \mathbf{n}(t), \mathbf{q}(t) \rangle = 0 ,
\]
</p>
<p> where  \( \mathbf{n}(t) = (\mathbf{q}_1(t) - \mathbf{p}_1(t)) \times (\mathbf{q}_2(t) -
\mathbf{p}_2(t)) \) and \( \mathbf{q}(t) = \mathbf{p}_2(t) - \mathbf{p}_1(t) \) using polynomial root finder from <a class="el" href="../../d0/de3/citelist.html#CITEREF_cem2022polyroot">[16]</a>.</p>
<p>See <a class="el" href="../../d0/de3/citelist.html#CITEREF_provot1997collision">[11]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_zachferg2021ccdbenchmark">[15]</a> for more details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TP1T</td><td>Type of the input matrix P1T </td></tr>
    <tr><td class="paramname">TQ1T</td><td>Type of the input matrix Q1T </td></tr>
    <tr><td class="paramname">TP2T</td><td>Type of the input matrix P2T </td></tr>
    <tr><td class="paramname">TQ2T</td><td>Type of the input matrix Q2T </td></tr>
    <tr><td class="paramname">TP1</td><td>Type of the input matrix P1 </td></tr>
    <tr><td class="paramname">TQ1</td><td>Type of the input matrix Q1 </td></tr>
    <tr><td class="paramname">TP2</td><td>Type of the input matrix P2 </td></tr>
    <tr><td class="paramname">TQ2</td><td>Type of the input matrix Q2 </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P1T</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the point P on edge 1 </td></tr>
    <tr><td class="paramname">Q1T</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the point Q on edge 1 </td></tr>
    <tr><td class="paramname">P2T</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the point P on edge 2 </td></tr>
    <tr><td class="paramname">Q2T</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the point Q on edge 2 </td></tr>
    <tr><td class="paramname">P1</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the point P on edge 1 </td></tr>
    <tr><td class="paramname">Q1</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the point Q on edge 1 </td></tr>
    <tr><td class="paramname">P2</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the point P on edge 2 </td></tr>
    <tr><td class="paramname">Q2</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the point Q on edge 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3-vector containing the time of impact and the barycentric coordinates </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If no intersection is found, <code>r[0] &lt; 0</code>, otherwise <code>r[0]</code> is the earliest time of impact </dd>
<dd>
<code>r[1]</code> and <code>r[2]</code> are the barycentric coordinates of the intersection point along  \((P1,Q1) \) and \( (P2,Q2) \) respectively </dd></dl>

</div>
</div>
<a id="a4901d411d4efdcab87a01633da21026f" name="a4901d411d4efdcab87a01633da21026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4901d411d4efdcab87a01633da21026f">&#9670;&#160;</a></span>ExpandBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE <a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a> pbat::geometry::ExpandBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands a 10-bit integer into 30 bits by inserting 2 zeros after each bit. </p>
<dl class="section note"><dt>Note</dt><dd>We make this (otherwise non-templated) function inline so that it gets compiled by nvcc whenever this header is included in cuda sources.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>10-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expanded 30-bit integer </dd></dl>

</div>
</div>
<a id="aebf105b6fa763e5397604209886043f1" name="aebf105b6fa763e5397604209886043f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf105b6fa763e5397604209886043f1">&#9670;&#160;</a></span>HashByXorOfPrimeMultiples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;common::CIndex THashed&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::geometry::HashByXorOfPrimeMultiples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a hash function used in <a class="el" href="../../d0/de3/citelist.html#CITEREF_teschner2003">[13]</a> for 2 or 3-vectors suitable as input to <a class="el" href="../../de/d29/classpbat_1_1geometry_1_1_hash_grid.html" title="HashGrid is a spatial partitioning data structure that divides 3D space into a sparse grid of cells,...">HashGrid</a>'s API. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">THashed</td><td>Integer type for the hash function's output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash function suitable for 2 or 3-vectors </dd></dl>

</div>
</div>
<a id="a5e669110bf2be65b77669262845b8ca4" name="a5e669110bf2be65b77669262845b8ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e669110bf2be65b77669262845b8ca4">&#9670;&#160;</a></span>KNearestNeighbours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kHeapCapacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pbat::geometry::KNearestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the (sorted) K objects with the smallest distances in a branch and bound tree rooted in root. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a branch and bound tree traversal algorithm, similar to NearestNeighbour. However, we maintain a min-distance-heap of all visited nodes so far, whose space complexities hould scale linearly w.r.t. the height of the tree, i.e. O(log(n)), where n is the number of nodes in the tree. By always visiting nodes closest to the query first, we quickly restrict the upper bound, pruning most of the search space. Each node visit costs approximately O(log(log(n)), due to heap insertions and deletions, but the total number of visits is expected to be much smaller than a generic depth-first traversal. However, the stack memory requirements are higher, due to storing node indices, distances, and types (i.e. node or leaf object).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">K</td><td>Number of nearest neighbours to find </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a367821018a940f7d4312b7473fde7516" name="a367821018a940f7d4312b7473fde7516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367821018a940f7d4312b7473fde7516">&#9670;&#160;</a></span>KNearestNeighbours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::KNearestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the (sorted) K objects with the smallest distances in a branch and bound tree rooted in root. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a branch and bound tree traversal algorithm, similar to NearestNeighbour. However, we maintain a min-distance-heap of all visited nodes so far, whose space complexities hould scale linearly w.r.t. the height of the tree, i.e. O(log(n)), where n is the number of nodes in the tree. By always visiting nodes closest to the query first, we quickly restrict the upper bound, pruning most of the search space. Each node visit costs approximately O(log(log(n)), due to heap insertions and deletions, but the total number of visits is expected to be much smaller than a generic depth-first traversal. However, the stack memory requirements are higher, due to storing node indices, distances, and types (i.e. node or leaf object).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">K</td><td>Number of nearest neighbours to find </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a3d5d222ddd9e4d2eb311482206330e8d" name="a3d5d222ddd9e4d2eb311482206330e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5d222ddd9e4d2eb311482206330e8d">&#9670;&#160;</a></span>MeshToAabbs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto kDims, auto kElemNodes, class TDerivedX, class TDerivedE, class TDerivedB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::geometry::MeshToAabbs </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedX &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes AABBs of nElemNodes simplex mesh elements in kDims dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kDims</td><td>Spatial dimension </td></tr>
    <tr><td class="paramname">kElemNodes</td><td>Number of nodes in an element </td></tr>
    <tr><td class="paramname">TDerivedX</td><td>Eigen dense expression type </td></tr>
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression type </td></tr>
    <tr><td class="paramname">TDerivedB</td><td>Eigen dense expression type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td><code>kDims x |# nodes|</code> matrix of node positions </td></tr>
    <tr><td class="paramname">E</td><td><code>kElemNodes x |# elements|</code> matrix of element node indices </td></tr>
    <tr><td class="paramname">B</td><td>2*kDims x |# elements| output AABBs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42669e95233f6352ec38496fbc1d9256" name="a42669e95233f6352ec38496fbc1d9256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42669e95233f6352ec38496fbc1d9256">&#9670;&#160;</a></span>MeshToAabbs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto kDims, auto kElemNodes, class TDerivedX, class TDerivedE, class TDerivedL, class TDerivedU&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::geometry::MeshToAabbs </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedX &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedU &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>U</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes AABBs of nElemNodes simplex mesh elements in kDims dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kDims</td><td>Spatial dimension </td></tr>
    <tr><td class="paramname">kElemNodes</td><td>Number of nodes in an element </td></tr>
    <tr><td class="paramname">TDerivedX</td><td>Eigen dense expression type </td></tr>
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression type </td></tr>
    <tr><td class="paramname">TDerivedL</td><td>Eigen dense expression type for lower bounds </td></tr>
    <tr><td class="paramname">TDerivedU</td><td>Eigen dense expression type for upper bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td><code>kDims x |# nodes|</code> matrix of node positions </td></tr>
    <tr><td class="paramname">E</td><td><code>kElemNodes x |# elements|</code> matrix of element node indices </td></tr>
    <tr><td class="paramname">L</td><td>kDims x |# elements| output AABBs lower bounds </td></tr>
    <tr><td class="paramname">U</td><td>kDims x |# elements| output AABBs upper bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad92bd1773247e0798ac5a5a6df79517" name="aad92bd1773247e0798ac5a5a6df79517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad92bd1773247e0798ac5a5a6df79517">&#9670;&#160;</a></span>Morton3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::CMorton3dPoint Point&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE <a class="el" href="#a930a1551ac51c87aae9dcd75f0163ee4">MortonCodeType</a> pbat::geometry::Morton3D </td>
          <td>(</td>
          <td class="paramtype">Point</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a 30-bit Morton code for the given 3D point located within the unit cube [0,1]. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Point</td><td>Type of the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>3D point located within the unit cube [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morton code of x </dd></dl>

</div>
</div>
<a id="a084206e1ce2988808849137dcb2e4a82" name="a084206e1ce2988808849137dcb2e4a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084206e1ce2988808849137dcb2e4a82">&#9670;&#160;</a></span>NearestToFurthestNeighbours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N, class TScalar, class TIndex, auto kHeapCapacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pbat::geometry::NearestToFurthestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse objects in a branch and bound tree rooted in root in increasing order of distance. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a branch and bound tree traversal algorithm, similar to NearestNeighbour. However, we maintain a min-distance-heap of all visited nodes so far, whose space complexities hould scale linearly w.r.t. the height of the tree, i.e. O(log(n)), where n is the number of nodes in the tree. By always visiting nodes closest to the query first, we quickly restrict the upper bound, pruning most of the search space. Each node visit costs approximately O(log(log(n)), due to heap insertions and deletions, but the total number of visits is expected to be much smaller than a generic depth-first traversal. However, the stack memory requirements are much higher, due to storing node indices, distances, and types (i.e. node or leaf object), and due to the search order not necessarily obeying a depth-first traversal.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>bool(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found, returns true if the search should continue </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="acde3e58b48638f69073cb5d0e200eb22" name="acde3e58b48638f69073cb5d0e200eb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde3e58b48638f69073cb5d0e200eb22">&#9670;&#160;</a></span>NearestToFurthestNeighbours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FDistanceLowerBound, class FDistance, class FOnFound, auto N = 2, class TScalar = Scalar, class TIndex = Index, auto kHeapCapacity = N * 1024&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::NearestToFurthestNeighbours </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistanceLowerBound</td>          <td class="paramname"><span class="paramname"><em>fLower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDistance</td>          <td class="paramname"><span class="paramname"><em>fDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScalar</td>          <td class="paramname"><span class="paramname"><em>fUpper</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;TScalar&#160;&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse objects in a branch and bound tree rooted in root in increasing order of distance. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a branch and bound tree traversal algorithm, similar to NearestNeighbour. However, we maintain a min-distance-heap of all visited nodes so far, whose space complexities hould scale linearly w.r.t. the height of the tree, i.e. O(log(n)), where n is the number of nodes in the tree. By always visiting nodes closest to the query first, we quickly restrict the upper bound, pruning most of the search space. Each node visit costs approximately O(log(log(n)), due to heap insertions and deletions, but the total number of visits is expected to be much smaller than a generic depth-first traversal. However, the stack memory requirements are much higher, due to storing node indices, distances, and types (i.e. node or leaf object), and due to the search order not necessarily obeying a depth-first traversal.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FDistanceLowerBound</td><td>Callable with signature <code>TScalar(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FDistance</td><td>Callable with signature <code>TScalar(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>bool(TIndex o, TScalar d, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar distance </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fLower</td><td>Function to compute the lower bound of the distance to node </td></tr>
    <tr><td class="paramname">fDistance</td><td>Function to compute the distance to object </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found, returns true if the search should continue </td></tr>
    <tr><td class="paramname">fUpper</td><td>Upper bound of the distance to the nearest neighbour </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a655d0e68b688c36b5798f0eb6ddc59e5" name="a655d0e68b688c36b5798f0eb6ddc59e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655d0e68b688c36b5798f0eb6ddc59e5">&#9670;&#160;</a></span>Overlaps() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodeOverlap, class FObjectOverlap, class FOnFound, auto N, class TIndex, auto kStackDepth&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pbat::geometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FNodeOverlap</td>          <td class="paramname"><span class="paramname"><em>fNodeOverlaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FObjectOverlap</td>          <td class="paramname"><span class="paramname"><em>fObjectOverlaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all nodes in a branch and bound tree that overlap with a given object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FNodeOverlaps</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FObjectOverlaps</td><td>Callable with signature <code>bool(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
    <tr><td class="paramname">kQueueSize</td><td>Maximum size of the nearest neighbour queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fNodeOverlaps</td><td>Function to determine if a node overlaps with the query </td></tr>
    <tr><td class="paramname">fObjectOverlaps</td><td>Function to determine if an object overlaps with the query </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="adcf85fc0664ca1101efadc446fa8fc24" name="adcf85fc0664ca1101efadc446fa8fc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf85fc0664ca1101efadc446fa8fc24">&#9670;&#160;</a></span>Overlaps() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodeOverlap, class FObjectOverlap, class FOnFound, auto N = 2, class TIndex = Index, auto kStackDepth = 64&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FNodeOverlap</td>          <td class="paramname"><span class="paramname"><em>fNodeOverlaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FObjectOverlap</td>          <td class="paramname"><span class="paramname"><em>fObjectOverlaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all nodes in a branch and bound tree that overlap with a given object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FNodeOverlaps</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FObjectOverlaps</td><td>Callable with signature <code>bool(TIndex o)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
    <tr><td class="paramname">kQueueSize</td><td>Maximum size of the nearest neighbour queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fNodeOverlaps</td><td>Function to determine if a node overlaps with the query </td></tr>
    <tr><td class="paramname">fObjectOverlaps</td><td>Function to determine if an object overlaps with the query </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="adc2eb6a69fb127bcd88f6f0b348a7e79" name="adc2eb6a69fb127bcd88f6f0b348a7e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2eb6a69fb127bcd88f6f0b348a7e79">&#9670;&#160;</a></span>Overlaps() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChildLhs, class FIsLeafLhs, class FLeafSizeLhs, class FLeafObjectLhs, class FChildRhs, class FIsLeafRhs, class FLeafSizeRhs, class FLeafObjectRhs, class FNodesOverlap, class FObjectsOverlap, class FOnFound, auto NLhs = 2, auto NRhs = 2, class TIndex = Index, auto kStackDepth = 128&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">FChildLhs</td>          <td class="paramname"><span class="paramname"><em>fChildLhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeafLhs</td>          <td class="paramname"><span class="paramname"><em>fIsLeafLhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSizeLhs</td>          <td class="paramname"><span class="paramname"><em>fLeafSizeLhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObjectLhs</td>          <td class="paramname"><span class="paramname"><em>fLeafObjectLhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FChildRhs</td>          <td class="paramname"><span class="paramname"><em>fChildRhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeafRhs</td>          <td class="paramname"><span class="paramname"><em>fIsLeafRhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSizeRhs</td>          <td class="paramname"><span class="paramname"><em>fLeafSizeRhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObjectRhs</td>          <td class="paramname"><span class="paramname"><em>fLeafObjectRhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FNodesOverlap</td>          <td class="paramname"><span class="paramname"><em>fNodesOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FObjectsOverlap</td>          <td class="paramname"><span class="paramname"><em>fObjectsOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>rootLhs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>rootRhs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes overlaps between two branch and bound trees. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChildLhs</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeafLhs</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSizeLhs</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObjectLhs</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FChildRhs</td><td>Callable with signature <code>template &lt;auto c&gt; TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FIsLeafRhs</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSizeRhs</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObjectRhs</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FNodesOverlap</td><td>Callable with signature <code>bool(TIndex nlhs, TIndex nrhs)</code> </td></tr>
    <tr><td class="paramname">FObjectsOverlap</td><td>Callable with signature <code>bool(TIndex olhs, TIndex orhs)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex olhs, TIndex orhs, TIndex k)</code> </td></tr>
    <tr><td class="paramname">NLhs</td><td>Number of children per node in the left tree </td></tr>
    <tr><td class="paramname">NRhs</td><td>Number of children per node in the right tree </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChildLhs</td><td>Function to get child c of a node in the left tree. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeafLhs</td><td>Function to determine if a node is a leaf node in the left tree </td></tr>
    <tr><td class="paramname">fLeafSizeLhs</td><td>Function to get the number of leaf objects in a node in the left tree </td></tr>
    <tr><td class="paramname">fLeafObjectLhs</td><td>Function to get the i-th leaf object in a node in the left tree </td></tr>
    <tr><td class="paramname">fChildRhs</td><td>Function to get child c of a node in the right tree. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeafRhs</td><td>Function to determine if a node is a leaf node in the right tree </td></tr>
    <tr><td class="paramname">fLeafSizeRhs</td><td>Function to get the number of leaf objects in a node in the right tree </td></tr>
    <tr><td class="paramname">fLeafObjectRhs</td><td>Function to get the i-th leaf object in a node in the right tree </td></tr>
    <tr><td class="paramname">fNodesOverlap</td><td>Function to determine if two nodes overlap </td></tr>
    <tr><td class="paramname">fObjectsOverlap</td><td>Function to determine if two objects overlap </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when an overlap is found </td></tr>
    <tr><td class="paramname">rootLhs</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node in the left tree to start the search from </td></tr>
    <tr><td class="paramname">rootRhs</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node in the right tree to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a5d60fff88ac0003c731dc470d0ab27d4" name="a5d60fff88ac0003c731dc470d0ab27d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d60fff88ac0003c731dc470d0ab27d4">&#9670;&#160;</a></span>PointTriangleCcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;math::linalg::mini::CReadableVectorizedMatrix TXT, math::linalg::mini::CReadableVectorizedMatrix TAT, math::linalg::mini::CReadableVectorizedMatrix TBT, math::linalg::mini::CReadableVectorizedMatrix TCT, math::linalg::mini::CReadableVectorizedMatrix TX, math::linalg::mini::CReadableVectorizedMatrix TA, math::linalg::mini::CReadableVectorizedMatrix TB, math::linalg::mini::CReadableVectorizedMatrix TC, class TScalar = typename TXT::ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE auto pbat::geometry::PointTriangleCcd </td>
          <td>(</td>
          <td class="paramtype">TXT const &amp;</td>          <td class="paramname"><span class="paramname"><em>XT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAT const &amp;</td>          <td class="paramname"><span class="paramname"><em>AT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBT const &amp;</td>          <td class="paramname"><span class="paramname"><em>BT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCT const &amp;</td>          <td class="paramname"><span class="paramname"><em>CT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TX const &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TA const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TB const &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TC const &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) -&gt; <a class="el" href="../../d6/d9a/classpbat_1_1math_1_1linalg_1_1mini_1_1_s_matrix.html">math::linalg::mini::SVector</a>&lt;TScalar, 4&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the time of impact \( t^* \) and barycentric coordinates \( \mathbf{\beta} \) of the intersection point between a point and a triangle moving along a linear trajectory. </p>
<p>Solves for roots (if any) in the range [0,1] of the polynomial   </p><p class="formulaDsp">
\[\langle \mathbf{n}(t), \mathbf{q}(t) \rangle = 0 ,
\]
</p>
<p> where  \( \mathbf{n}(t) = (\mathbf{b}(t) - \mathbf{a}(t)) \times (\mathbf{c}(t) - \mathbf{a}(t))
\) and \( \mathbf{q}(t) = \mathbf{x}(t) - \mathbf{a}(t) \) using polynomial root finder from <a class="el" href="../../d0/de3/citelist.html#CITEREF_cem2022polyroot">[16]</a>.</p>
<p>See <a class="el" href="../../d0/de3/citelist.html#CITEREF_provot1997collision">[11]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_zachferg2021ccdbenchmark">[15]</a> for more details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>Type of the input matrix XT </td></tr>
    <tr><td class="paramname">TAT</td><td>Type of the input matrix AT </td></tr>
    <tr><td class="paramname">TBT</td><td>Type of the input matrix BT </td></tr>
    <tr><td class="paramname">TCT</td><td>Type of the input matrix CT </td></tr>
    <tr><td class="paramname">TX</td><td>Type of the input matrix X </td></tr>
    <tr><td class="paramname">TA</td><td>Type of the input matrix A </td></tr>
    <tr><td class="paramname">TB</td><td>Type of the input matrix B </td></tr>
    <tr><td class="paramname">TC</td><td>Type of the input matrix C </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of the scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">XT</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the point </td></tr>
    <tr><td class="paramname">AT</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the triangle vertex A </td></tr>
    <tr><td class="paramname">BT</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the triangle vertex B </td></tr>
    <tr><td class="paramname">CT</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the initial positions of the triangle vertex C </td></tr>
    <tr><td class="paramname">X</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the point </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the triangle vertex A </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the triangle vertex B </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#af27842f3602e4a1729856deb55012fe7" title="Fixed-size matrix type.">Matrix</a> of the final positions of the triangle vertex C </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 4-vector <code>r</code> containing the time of impact and the barycentric coordinates. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If no intersection is found, <code>r[0] &lt; 0</code>, otherwise <code>r[0] &gt;= 0</code> is the earliest time of impact (subject to floating point error). </dd></dl>

</div>
</div>
<a id="ad318504f4d24918e58f8f4780f384eaf" name="ad318504f4d24918e58f8f4780f384eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad318504f4d24918e58f8f4780f384eaf">&#9670;&#160;</a></span>SelfOverlaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FChild, class FIsLeaf, class FLeafSize, class FLeafObject, class FNodesOverlap, class FObjectsOverlap, class FOnFound, auto N = 2, class TIndex = Index, auto kStackDepth = 128&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE bool pbat::geometry::SelfOverlaps </td>
          <td>(</td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIsLeaf</td>          <td class="paramname"><span class="paramname"><em>fIsLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafSize</td>          <td class="paramname"><span class="paramname"><em>fLeafSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLeafObject</td>          <td class="paramname"><span class="paramname"><em>fLeafObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FNodesOverlap</td>          <td class="paramname"><span class="paramname"><em>fNodesOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FObjectsOverlap</td>          <td class="paramname"><span class="paramname"><em>fObjectsOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnFound</td>          <td class="paramname"><span class="paramname"><em>fOnFound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute overlapping nodes from a branch and bound tree rooted in root. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FChild</td><td>Callable with signature <code>template &lt;auto c&gt; <a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index(TIndex node)</a></code> </td></tr>
    <tr><td class="paramname">FIsLeaf</td><td>Callable with signature <code>bool(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafSize</td><td>Callable with signature <code>TIndex(TIndex node)</code> </td></tr>
    <tr><td class="paramname">FLeafObject</td><td>Callable with signature <code>TIndex(TIndex node, TIndex i)</code> </td></tr>
    <tr><td class="paramname">FNodesOverlap</td><td>Callable with signature <code>bool(TIndex n1, TIndex n2)</code> </td></tr>
    <tr><td class="paramname">FObjectsOverlap</td><td>Callable with signature <code>bool(TIndex o1, TIndex o2)</code> </td></tr>
    <tr><td class="paramname">FOnFound</td><td>Callable with signature <code>void(TIndex o1, TIndex o2, TIndex k)</code> </td></tr>
    <tr><td class="paramname">N</td><td>Max number of children per node </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
    <tr><td class="paramname">kQueueSize</td><td>Maximum size of the nearest neighbour queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fChild</td><td>Function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">fIsLeaf</td><td>Function to determine if a node is a leaf node </td></tr>
    <tr><td class="paramname">fLeafSize</td><td>Function to get the number of leaf objects in a node </td></tr>
    <tr><td class="paramname">fLeafObject</td><td>Function to get the i-th leaf object in a node </td></tr>
    <tr><td class="paramname">fNodesOverlap</td><td>Function to determine if 2 nodes overlap </td></tr>
    <tr><td class="paramname">fObjectsOverlap</td><td>Function to determine if 2 objects overlap </td></tr>
    <tr><td class="paramname">fOnFound</td><td>Function to call when a nearest neighbour is found </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the traversal completed, false if it was stopped early due to insufficient stack capacity </dd></dl>

</div>
</div>
<a id="a2139bf2b76ae61c75231843b82cc0dc8" name="a2139bf2b76ae61c75231843b82cc0dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2139bf2b76ae61c75231843b82cc0dc8">&#9670;&#160;</a></span>SimplexMeshBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;common::CIndex TIndex = Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::geometry::SimplexMeshBoundary </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Matrix&lt; TIndex, Eigen::Dynamic, Eigen::Dynamic &gt; const &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) -&gt; std::tuple&lt;
        Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;,
        Eigen::Matrix&lt;TIndex, Eigen::Dynamic, Eigen::Dynamic&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the boundary mesh of a simplex mesh. </p>
<dl class="section note"><dt>Note</dt><dd>Only works for triangle (<code>C.rows()==3</code>) and tetrahedral (<code>C.rows()==4</code>) meshes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>The index type used in the mesh (default: <code><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The connectivity matrix of the mesh (i.e. the simplices) </td></tr>
    <tr><td class="paramname">n</td><td>The number of vertices in the mesh. If -1, the number of vertices is computed from C. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the boundary vertices and the boundary facets </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d7c/namespacepbat.html">pbat</a></li><li class="navelem"><a class="el" href="../../d2/d7a/namespacepbat_1_1geometry.html">geometry</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
