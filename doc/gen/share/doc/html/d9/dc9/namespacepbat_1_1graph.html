<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.13.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PhysicsBasedAnimationToolkit: pbat::graph Namespace Reference</title>
  <link rel="icon" href="../../entei.icon.png" type="image/x-icon" />
  <link href="../../tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="../../jquery.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
  <!-- BEGIN Doxygen Awesome -->
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeTabs.init()
  </script>
  <!-- END Doxygen Awesome -->
  <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
  <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="../../pbat.svg"  /></td>
              <td id="projectalign">
                <div id="projectname">PhysicsBasedAnimationToolkit<span
                    id="projectnumber">&#160;0.0.10</span>
                </div>
                <div id="projectbrief">Cross-platform C++20 library of algorithms and data structures commonly used in computer graphics research on physically-based simulation.</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/dc9/namespacepbat_1_1graph.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pbat::graph Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db5/structpbat_1_1graph_1_1_breadth_first_search.html">BreadthFirstSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d07/structpbat_1_1graph_1_1_depth_first_search.html">DepthFirstSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d77/classpbat_1_1graph_1_1_disjoint_set_union_find.html">DisjointSetUnionFind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint Set Union-Find data structure.  <a href="../../d9/d77/classpbat_1_1graph_1_1_disjoint_set_union_find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html">PartitioningOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for graph partitioning.  <a href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d6b/structpbat_1_1graph_1_1_weighted_edge_traits.html">WeightedEdgeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits for <a class="el" href="#a353fbeda472647a2e3af2031e2170fcc" title="Weighted edge (wrapper around Eigen triplet type)">WeightedEdge</a>.  <a href="../../df/d6b/structpbat_1_1graph_1_1_weighted_edge_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a353fbeda472647a2e3af2031e2170fcc" id="r_a353fbeda472647a2e3af2031e2170fcc"><td class="memTemplParams" colspan="2">template&lt;class TWeight = Scalar, class TIndex = Index&gt; </td></tr>
<tr class="memitem:a353fbeda472647a2e3af2031e2170fcc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a353fbeda472647a2e3af2031e2170fcc">WeightedEdge</a> = Eigen::Triplet&lt;TWeight, TIndex&gt;</td></tr>
<tr class="memdesc:a353fbeda472647a2e3af2031e2170fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted edge (wrapper around Eigen triplet type)  <br /></td></tr>
<tr class="separator:a353fbeda472647a2e3af2031e2170fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aae94ec1f32cf36a23c873b18b0400645" id="r_aae94ec1f32cf36a23c873b18b0400645"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae94ec1f32cf36a23c873b18b0400645">EGreedyColorSelectionStrategy</a> { <a class="el" href="#aae94ec1f32cf36a23c873b18b0400645a98f052a90774dc8335e422b6076b9da3">LeastUsed</a>
, <a class="el" href="#aae94ec1f32cf36a23c873b18b0400645a235215d0fea7b04bb18198d5e07e2541">FirstAvailable</a>
 }</td></tr>
<tr class="memdesc:aae94ec1f32cf36a23c873b18b0400645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of color selection strategies for graph coloring algorithms.  <a href="#aae94ec1f32cf36a23c873b18b0400645">More...</a><br /></td></tr>
<tr class="separator:aae94ec1f32cf36a23c873b18b0400645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26166ca4b423603403a335c47224b45" id="r_ac26166ca4b423603403a335c47224b45"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac26166ca4b423603403a335c47224b45">EGreedyColorOrderingStrategy</a> { <a class="el" href="#ac26166ca4b423603403a335c47224b45a2bd8ab451a35759c5737128e35c8011a">Natural</a>
, <a class="el" href="#ac26166ca4b423603403a335c47224b45af833dddbfc0d8a5887bd441ff83f6db8">SmallestDegree</a>
, <a class="el" href="#ac26166ca4b423603403a335c47224b45a2ddb2b46f6e9567f5a44c430f996f536">LargestDegree</a>
 }</td></tr>
<tr class="memdesc:ac26166ca4b423603403a335c47224b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of vertex traversal ordering strategies for graph coloring algorithms.  <a href="#ac26166ca4b423603403a335c47224b45">More...</a><br /></td></tr>
<tr class="separator:ac26166ca4b423603403a335c47224b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7c7df4fe22b56ba7f39c144f8aac9" id="r_a7cb7c7df4fe22b56ba7f39c144f8aac9"><td class="memItemLeft" align="right" valign="top"><a id="a7cb7c7df4fe22b56ba7f39c144f8aac9" name="a7cb7c7df4fe22b56ba7f39c144f8aac9"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cb7c7df4fe22b56ba7f39c144f8aac9">EMeshDualGraphOptions</a> : std::int32_t { <b>VertexAdjacent</b> = 0b001
, <b>EdgeAdjacent</b> = 0b010
, <b>FaceAdjacent</b> = 0b100
, <b>All</b> = 0b111
 }</td></tr>
<tr class="memdesc:a7cb7c7df4fe22b56ba7f39c144f8aac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of dual graph adjacencies. <br /></td></tr>
<tr class="separator:a7cb7c7df4fe22b56ba7f39c144f8aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45a34060adf31a752bdf78e10fd1fe38" id="r_a45a34060adf31a752bdf78e10fd1fe38"><td class="memTemplParams" colspan="2">template&lt;class TWeightedEdgeIterator, class TWeightedEdge = typename std::iterator_traits&lt;TWeightedEdgeIterator&gt;::value_type, class TScalar = typename WeightedEdgeTraits&lt;TWeightedEdge&gt;::ScalarType, class TIndex = typename WeightedEdgeTraits&lt;TWeightedEdge&gt;::IndexType&gt; </td></tr>
<tr class="memitem:a45a34060adf31a752bdf78e10fd1fe38"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45a34060adf31a752bdf78e10fd1fe38">AdjacencyMatrixFromEdges</a> (TWeightedEdgeIterator begin, TWeightedEdgeIterator end, TIndex m=TIndex(-1), TIndex n=TIndex(-1)) -&gt; Eigen::SparseMatrix&lt; TScalar, Eigen::RowMajor, TIndex &gt;</td></tr>
<tr class="memdesc:a45a34060adf31a752bdf78e10fd1fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency matrix from edge/triplet list.  <br /></td></tr>
<tr class="separator:a45a34060adf31a752bdf78e10fd1fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4416e18f2df874097fd12399ed6d549" id="r_af4416e18f2df874097fd12399ed6d549"><td class="memTemplParams" colspan="2">template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </td></tr>
<tr class="memitem:af4416e18f2df874097fd12399ed6d549"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4416e18f2df874097fd12399ed6d549">AdjacencyMatrixPrefix</a> (Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;A)</td></tr>
<tr class="memdesc:af4416e18f2df874097fd12399ed6d549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning wrapper around the offset pointers of a compressed sparse matrix.  <br /></td></tr>
<tr class="separator:af4416e18f2df874097fd12399ed6d549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c29573233e8e81614d48855793c943" id="r_a54c29573233e8e81614d48855793c943"><td class="memTemplParams" colspan="2">template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </td></tr>
<tr class="memitem:a54c29573233e8e81614d48855793c943"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54c29573233e8e81614d48855793c943">AdjacencyMatrixIndices</a> (Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;A)</td></tr>
<tr class="memdesc:a54c29573233e8e81614d48855793c943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning wrapper around the indices of a compressed sparse matrix.  <br /></td></tr>
<tr class="separator:a54c29573233e8e81614d48855793c943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94d34837d4b43952f774e6832bb3128" id="r_ae94d34837d4b43952f774e6832bb3128"><td class="memTemplParams" colspan="2">template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </td></tr>
<tr class="memitem:ae94d34837d4b43952f774e6832bb3128"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae94d34837d4b43952f774e6832bb3128">AdjacencyMatrixWeights</a> (Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;A)</td></tr>
<tr class="memdesc:ae94d34837d4b43952f774e6832bb3128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning wrapper around the weights of a compressed sparse matrix.  <br /></td></tr>
<tr class="separator:ae94d34837d4b43952f774e6832bb3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2db92c83d3d9964a4d5170a349238c" id="r_a6c2db92c83d3d9964a4d5170a349238c"><td class="memTemplParams" colspan="2">template&lt;class TDerivedP, std::integral TIndex = typename TDerivedP::Scalar&gt; </td></tr>
<tr class="memitem:a6c2db92c83d3d9964a4d5170a349238c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c2db92c83d3d9964a4d5170a349238c">MapToAdjacency</a> (Eigen::DenseBase&lt; TDerivedP &gt; const &amp;p, TIndex n=TIndex(-1)) -&gt; std::tuple&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;, Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="memdesc:a6c2db92c83d3d9964a4d5170a349238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency list in compressed sparse format from a map p s.t. p(i) is the index of the vertex adjacent to i.  <br /></td></tr>
<tr class="separator:a6c2db92c83d3d9964a4d5170a349238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb8189ed58658d208ade64f5daf66d0" id="r_aeeb8189ed58658d208ade64f5daf66d0"><td class="memTemplParams" colspan="2">template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </td></tr>
<tr class="memitem:aeeb8189ed58658d208ade64f5daf66d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeeb8189ed58658d208ade64f5daf66d0">MatrixToAdjacency</a> (Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;A)</td></tr>
<tr class="memdesc:aeeb8189ed58658d208ade64f5daf66d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the offset and indices arrays of an input adjacency matrix.  <br /></td></tr>
<tr class="separator:aeeb8189ed58658d208ade64f5daf66d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e4b9a72106fc61acfdf7a99d01ac13" id="r_a69e4b9a72106fc61acfdf7a99d01ac13"><td class="memTemplParams" colspan="2">template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </td></tr>
<tr class="memitem:a69e4b9a72106fc61acfdf7a99d01ac13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69e4b9a72106fc61acfdf7a99d01ac13">MatrixToWeightedAdjacency</a> (Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;A)</td></tr>
<tr class="memdesc:a69e4b9a72106fc61acfdf7a99d01ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency list in compressed sparse format from an input adjacency matrix.  <br /></td></tr>
<tr class="separator:a69e4b9a72106fc61acfdf7a99d01ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3f0177c97f73f1ff4de2f336e7b6a" id="r_a4bf3f0177c97f73f1ff4de2f336e7b6a"><td class="memTemplParams" colspan="2">template&lt;class TIndex = Index&gt; </td></tr>
<tr class="memitem:a4bf3f0177c97f73f1ff4de2f336e7b6a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bf3f0177c97f73f1ff4de2f336e7b6a">ListOfListsToAdjacency</a> (std::vector&lt; std::vector&lt; TIndex &gt; &gt; const &amp;lil)</td></tr>
<tr class="memdesc:a4bf3f0177c97f73f1ff4de2f336e7b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency list in compressed sparse format from an input adjacency list in list of lists format.  <br /></td></tr>
<tr class="separator:a4bf3f0177c97f73f1ff4de2f336e7b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b44563432fa5affdc87403cbfdcaff6" id="r_a3b44563432fa5affdc87403cbfdcaff6"><td class="memTemplParams" colspan="2">template&lt;class TDerivedPtr, class TDerivedAdj, class TIndex = typename TDerivedPtr::Scalar, class Func&gt; </td></tr>
<tr class="memitem:a3b44563432fa5affdc87403cbfdcaff6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b44563432fa5affdc87403cbfdcaff6">ForEachEdge</a> (Eigen::DenseBase&lt; TDerivedPtr &gt; &amp;ptr, Eigen::DenseBase&lt; TDerivedAdj &gt; &amp;adj, Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a3b44563432fa5affdc87403cbfdcaff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge iteration over the adjacency list in compressed sparse format.  <br /></td></tr>
<tr class="separator:a3b44563432fa5affdc87403cbfdcaff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2c0accc9a57ed6650ef2bb957f7113" id="r_a7c2c0accc9a57ed6650ef2bb957f7113"><td class="memTemplParams" colspan="2">template&lt;class TDerivedPtr, class TDerivedAdj, class TIndex = typename TDerivedPtr::Scalar, class Func&gt; </td></tr>
<tr class="memitem:a7c2c0accc9a57ed6650ef2bb957f7113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c2c0accc9a57ed6650ef2bb957f7113">RemoveEdges</a> (Eigen::DenseBase&lt; TDerivedPtr &gt; &amp;ptr, Eigen::DenseBase&lt; TDerivedAdj &gt; &amp;adj, Func fShouldDeleteEdge)</td></tr>
<tr class="memdesc:a7c2c0accc9a57ed6650ef2bb957f7113"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place removal of edges from the adjacency list in compressed sparse format.  <br /></td></tr>
<tr class="separator:a7c2c0accc9a57ed6650ef2bb957f7113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1853b76a08732c08e8dcd42169ce8f0e" id="r_a1853b76a08732c08e8dcd42169ce8f0e"><td class="memTemplParams" colspan="2">template&lt;class TDerivedPtr, class TDerivedAdj, int NC = 128, std::integral TIndex = typename TDerivedPtr::Scalar&gt; </td></tr>
<tr class="memitem:a1853b76a08732c08e8dcd42169ce8f0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1853b76a08732c08e8dcd42169ce8f0e">GreedyColor</a> (Eigen::DenseBase&lt; TDerivedPtr &gt; const &amp;ptr, Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;adj, <a class="el" href="#ac26166ca4b423603403a335c47224b45">EGreedyColorOrderingStrategy</a> eOrderingStrategy=<a class="el" href="#ac26166ca4b423603403a335c47224b45a2ddb2b46f6e9567f5a44c430f996f536">EGreedyColorOrderingStrategy::LargestDegree</a>, <a class="el" href="#aae94ec1f32cf36a23c873b18b0400645">EGreedyColorSelectionStrategy</a> eSelectionStrategy=<a class="el" href="#aae94ec1f32cf36a23c873b18b0400645a98f052a90774dc8335e422b6076b9da3">EGreedyColorSelectionStrategy::LeastUsed</a>) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a1853b76a08732c08e8dcd42169ce8f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedy graph coloring algorithm.  <br /></td></tr>
<tr class="separator:a1853b76a08732c08e8dcd42169ce8f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfa69754d880587ebd67c7776a12f95" id="r_aabfa69754d880587ebd67c7776a12f95"><td class="memTemplParams" colspan="2">template&lt;common::CIndex TIndex, class TDerivedP, class TDerivedAdj&gt; </td></tr>
<tr class="memitem:aabfa69754d880587ebd67c7776a12f95"><td class="memTemplItemLeft" align="right" valign="top">TIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabfa69754d880587ebd67c7776a12f95">ConnectedComponents</a> (Eigen::DenseBase&lt; TDerivedP &gt; const &amp;ptr, Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;adj, Eigen::Ref&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt; &gt; components, <a class="el" href="../../d4/d07/structpbat_1_1graph_1_1_depth_first_search.html">DepthFirstSearch</a>&lt; TIndex &gt; &amp;dfs)</td></tr>
<tr class="memdesc:aabfa69754d880587ebd67c7776a12f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of a graph using depth-first search.  <br /></td></tr>
<tr class="separator:aabfa69754d880587ebd67c7776a12f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e6296ebb78444e9e6440d5fe7cfbd" id="r_ab48e6296ebb78444e9e6440d5fe7cfbd"><td class="memTemplParams" colspan="2">template&lt;common::CIndex TIndex, class TDerivedP, class TDerivedAdj&gt; </td></tr>
<tr class="memitem:ab48e6296ebb78444e9e6440d5fe7cfbd"><td class="memTemplItemLeft" align="right" valign="top">TIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab48e6296ebb78444e9e6440d5fe7cfbd">ConnectedComponents</a> (Eigen::DenseBase&lt; TDerivedP &gt; const &amp;ptr, Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;adj, Eigen::Ref&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt; &gt; components, <a class="el" href="../../de/db5/structpbat_1_1graph_1_1_breadth_first_search.html">BreadthFirstSearch</a>&lt; TIndex &gt; &amp;bfs)</td></tr>
<tr class="memdesc:ab48e6296ebb78444e9e6440d5fe7cfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of a graph using breadth-first search.  <br /></td></tr>
<tr class="separator:ab48e6296ebb78444e9e6440d5fe7cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92708086f95b45eca0c636ee7e4a9864" id="r_a92708086f95b45eca0c636ee7e4a9864"><td class="memTemplParams" colspan="2">template&lt;class TDerivedE, class TDerivedW, common::CIndex TIndex = typename TDerivedE::Scalar, common::CArithmetic TScalar = typename TDerivedW::Scalar&gt; </td></tr>
<tr class="memitem:a92708086f95b45eca0c636ee7e4a9864"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92708086f95b45eca0c636ee7e4a9864">MeshAdjacencyMatrix</a> (Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, Eigen::DenseBase&lt; TDerivedW &gt; const &amp;w, TIndex nNodes=TIndex(-1), bool bVertexToElement=false, bool bHasDuplicates=false) -&gt; Eigen::SparseMatrix&lt; TScalar, Eigen::ColMajor, TIndex &gt;</td></tr>
<tr class="memdesc:a92708086f95b45eca0c636ee7e4a9864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency matrix from mesh.  <br /></td></tr>
<tr class="separator:a92708086f95b45eca0c636ee7e4a9864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef0f0cc7fa6bd2ba1b423e21c40e5f4" id="r_a2ef0f0cc7fa6bd2ba1b423e21c40e5f4"><td class="memTemplParams" colspan="2">template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </td></tr>
<tr class="memitem:a2ef0f0cc7fa6bd2ba1b423e21c40e5f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ef0f0cc7fa6bd2ba1b423e21c40e5f4">MeshAdjacencyMatrix</a> (Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, TIndex nNodes=TIndex(-1), bool bVertexToElement=false, bool bHasDuplicates=false) -&gt; Eigen::SparseMatrix&lt; TIndex, Eigen::ColMajor, TIndex &gt;</td></tr>
<tr class="memdesc:a2ef0f0cc7fa6bd2ba1b423e21c40e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct adjacency matrix from mesh.  <br /></td></tr>
<tr class="separator:a2ef0f0cc7fa6bd2ba1b423e21c40e5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc67838583486d2d0d3b939242007a" id="r_a9bfc67838583486d2d0d3b939242007a"><td class="memTemplParams" colspan="2">template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </td></tr>
<tr class="memitem:a9bfc67838583486d2d0d3b939242007a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bfc67838583486d2d0d3b939242007a">MeshPrimalGraph</a> (Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, TIndex nNodes=TIndex(-1)) -&gt; Eigen::SparseMatrix&lt; TIndex, Eigen::ColMajor, TIndex &gt;</td></tr>
<tr class="memdesc:a9bfc67838583486d2d0d3b939242007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct primal graph of input mesh, i.e. the graph of adjacent vertices.  <br /></td></tr>
<tr class="separator:a9bfc67838583486d2d0d3b939242007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27c11cf51026074641f54fc63afc13a" id="r_aa27c11cf51026074641f54fc63afc13a"><td class="memTemplParams" colspan="2">template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </td></tr>
<tr class="memitem:aa27c11cf51026074641f54fc63afc13a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa27c11cf51026074641f54fc63afc13a">MeshDualGraph</a> (Eigen::DenseBase&lt; TDerivedE &gt; const &amp;E, TIndex nNodes=TIndex(-1), <a class="el" href="#a7cb7c7df4fe22b56ba7f39c144f8aac9">EMeshDualGraphOptions</a> opts=EMeshDualGraphOptions::All) -&gt; Eigen::SparseMatrix&lt; TIndex, Eigen::ColMajor, TIndex &gt;</td></tr>
<tr class="memdesc:aa27c11cf51026074641f54fc63afc13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dual graph of input mesh, i.e. the graph of adjacent elements.  <br /></td></tr>
<tr class="separator:aa27c11cf51026074641f54fc63afc13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a43676f2a845657e69033d1a7cbee" id="r_a354a43676f2a845657e69033d1a7cbee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a354a43676f2a845657e69033d1a7cbee">Partition</a> (Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const  &gt; const  &amp;ptr, Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const  &gt; const  &amp;adj, Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const  &gt; const  &amp;wadj, <a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a> nPartitions, <a class="el" href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html">PartitioningOptions</a> opts=<a class="el" href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html">PartitioningOptions</a>{})</td></tr>
<tr class="memdesc:a354a43676f2a845657e69033d1a7cbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition input graph.  <br /></td></tr>
<tr class="separator:a354a43676f2a845657e69033d1a7cbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graph algorithms and data structures </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a353fbeda472647a2e3af2031e2170fcc" name="a353fbeda472647a2e3af2031e2170fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353fbeda472647a2e3af2031e2170fcc">&#9670;&#160;</a></span>WeightedEdge</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TWeight = Scalar, class TIndex = Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a353fbeda472647a2e3af2031e2170fcc">pbat::graph::WeightedEdge</a> = Eigen::Triplet&lt;TWeight, TIndex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighted edge (wrapper around Eigen triplet type) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TWeight</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac26166ca4b423603403a335c47224b45" name="ac26166ca4b423603403a335c47224b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26166ca4b423603403a335c47224b45">&#9670;&#160;</a></span>EGreedyColorOrderingStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac26166ca4b423603403a335c47224b45">pbat::graph::EGreedyColorOrderingStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of vertex traversal ordering strategies for graph coloring algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac26166ca4b423603403a335c47224b45a2bd8ab451a35759c5737128e35c8011a" name="ac26166ca4b423603403a335c47224b45a2bd8ab451a35759c5737128e35c8011a"></a>Natural&#160;</td><td class="fielddoc"><p>Natural ordering of the vertices (i.e. [0,n-1]) </p>
</td></tr>
<tr><td class="fieldname"><a id="ac26166ca4b423603403a335c47224b45af833dddbfc0d8a5887bd441ff83f6db8" name="ac26166ca4b423603403a335c47224b45af833dddbfc0d8a5887bd441ff83f6db8"></a>SmallestDegree&#160;</td><td class="fielddoc"><p>Always visit the vertex with the smallest degree next. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac26166ca4b423603403a335c47224b45a2ddb2b46f6e9567f5a44c430f996f536" name="ac26166ca4b423603403a335c47224b45a2ddb2b46f6e9567f5a44c430f996f536"></a>LargestDegree&#160;</td><td class="fielddoc"><p>Always visit the vertex with the largest degree next. </p>
</td></tr>
</table>

</div>
</div>
<a id="aae94ec1f32cf36a23c873b18b0400645" name="aae94ec1f32cf36a23c873b18b0400645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae94ec1f32cf36a23c873b18b0400645">&#9670;&#160;</a></span>EGreedyColorSelectionStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aae94ec1f32cf36a23c873b18b0400645">pbat::graph::EGreedyColorSelectionStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of color selection strategies for graph coloring algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aae94ec1f32cf36a23c873b18b0400645a98f052a90774dc8335e422b6076b9da3" name="aae94ec1f32cf36a23c873b18b0400645a98f052a90774dc8335e422b6076b9da3"></a>LeastUsed&#160;</td><td class="fielddoc"><p>Select the least used color from the color palette. </p>
</td></tr>
<tr><td class="fieldname"><a id="aae94ec1f32cf36a23c873b18b0400645a235215d0fea7b04bb18198d5e07e2541" name="aae94ec1f32cf36a23c873b18b0400645a235215d0fea7b04bb18198d5e07e2541"></a>FirstAvailable&#160;</td><td class="fielddoc"><p>Select the first available color from the color palette. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a45a34060adf31a752bdf78e10fd1fe38" name="a45a34060adf31a752bdf78e10fd1fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a34060adf31a752bdf78e10fd1fe38">&#9670;&#160;</a></span>AdjacencyMatrixFromEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TWeightedEdgeIterator, class TWeightedEdge = typename std::iterator_traits&lt;TWeightedEdgeIterator&gt;::value_type, class TScalar = typename WeightedEdgeTraits&lt;TWeightedEdge&gt;::ScalarType, class TIndex = typename WeightedEdgeTraits&lt;TWeightedEdge&gt;::IndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::AdjacencyMatrixFromEdges </td>
          <td>(</td>
          <td class="paramtype">TWeightedEdgeIterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TWeightedEdgeIterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>m</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>&#160;) -&gt; Eigen::SparseMatrix&lt;TScalar, Eigen::RowMajor, TIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency matrix from edge/triplet list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TWeightedEdgeIterator</td><td>Iterator type of the edge list </td></tr>
    <tr><td class="paramname">TWeightedEdge</td><td>Type of the edge </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the beginning of the edge list </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to the end of the edge list </td></tr>
    <tr><td class="paramname">m</td><td>Number of rows of the adjacency matrix. If not provided (i.e. m &lt; 0), it is inferred from the edge list. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns of the adjacency matrix. If not provided (i.e. n &lt; 0), it is inferred from the edge list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjacency matrix </dd></dl>

</div>
</div>
<a id="a54c29573233e8e81614d48855793c943" name="a54c29573233e8e81614d48855793c943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c29573233e8e81614d48855793c943">&#9670;&#160;</a></span>AdjacencyMatrixIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::AdjacencyMatrixIndices </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-owning wrapper around the indices of a compressed sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedA</td><td>Type of input adjacency matrix </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-owning wrapper around the indices of the adjacency matrix </dd></dl>

</div>
</div>
<a id="af4416e18f2df874097fd12399ed6d549" name="af4416e18f2df874097fd12399ed6d549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4416e18f2df874097fd12399ed6d549">&#9670;&#160;</a></span>AdjacencyMatrixPrefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::AdjacencyMatrixPrefix </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-owning wrapper around the offset pointers of a compressed sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedA</td><td>Type of input adjacency matrix </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-owning wrapper around the offset pointers of the adjacency matrix </dd></dl>

</div>
</div>
<a id="ae94d34837d4b43952f774e6832bb3128" name="ae94d34837d4b43952f774e6832bb3128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94d34837d4b43952f774e6832bb3128">&#9670;&#160;</a></span>AdjacencyMatrixWeights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::AdjacencyMatrixWeights </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-owning wrapper around the weights of a compressed sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedA</td><td>Type of input adjacency matrix </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-owning wrapper around the weights of the adjacency matrix </dd></dl>

</div>
</div>
<a id="ab48e6296ebb78444e9e6440d5fe7cfbd" name="ab48e6296ebb78444e9e6440d5fe7cfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48e6296ebb78444e9e6440d5fe7cfbd">&#9670;&#160;</a></span>ConnectedComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;common::CIndex TIndex, class TDerivedP, class TDerivedAdj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIndex pbat::graph::ConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedP &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>components</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db5/structpbat_1_1graph_1_1_breadth_first_search.html">BreadthFirstSearch</a>&lt; TIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connected components of a graph using breadth-first search. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type used in the graph </td></tr>
    <tr><td class="paramname">TDerivedP</td><td>Type of the pointer vector (adjacency list start indices for each vertex) </td></tr>
    <tr><td class="paramname">TDerivedAdj</td><td>Type of the adjacency list (vector of vertex indices) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the start of each vertex's adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Adjacency list of the graph </td></tr>
    <tr><td class="paramname">components</td><td>Output vector to store component labels for each vertex </td></tr>
    <tr><td class="paramname">bfs</td><td>Breadth-first search object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connected components found in the graph </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>components[u] &lt; 0</code> for all vertices <code>u</code> in the graph </dd></dl>

</div>
</div>
<a id="aabfa69754d880587ebd67c7776a12f95" name="aabfa69754d880587ebd67c7776a12f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfa69754d880587ebd67c7776a12f95">&#9670;&#160;</a></span>ConnectedComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;common::CIndex TIndex, class TDerivedP, class TDerivedAdj&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIndex pbat::graph::ConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedP &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>components</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d07/structpbat_1_1graph_1_1_depth_first_search.html">DepthFirstSearch</a>&lt; TIndex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dfs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connected components of a graph using depth-first search. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type used in the graph </td></tr>
    <tr><td class="paramname">TDerivedP</td><td>Type of the pointer vector (adjacency list start indices for each vertex) </td></tr>
    <tr><td class="paramname">TDerivedAdj</td><td>Type of the adjacency list (vector of vertex indices) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the start of each vertex's adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Adjacency list of the graph </td></tr>
    <tr><td class="paramname">components</td><td>Output vector to store component labels for each vertex </td></tr>
    <tr><td class="paramname">dfs</td><td>Depth-first search object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connected components found in the graph </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>components[u] &lt; 0</code> for all vertices <code>u</code> in the graph </dd></dl>

</div>
</div>
<a id="a3b44563432fa5affdc87403cbfdcaff6" name="a3b44563432fa5affdc87403cbfdcaff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b44563432fa5affdc87403cbfdcaff6">&#9670;&#160;</a></span>ForEachEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedPtr, class TDerivedAdj, class TIndex = typename TDerivedPtr::Scalar, class Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::graph::ForEachEdge </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedPtr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedAdj &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edge iteration over the adjacency list in compressed sparse format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedPtr</td><td>Eigen dense expression of the offset pointers of the adjacency list </td></tr>
    <tr><td class="paramname">TDerivedAdj</td><td>Eigen dense expression of the indices of the adjacency list </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
    <tr><td class="paramname">Func</td><td>Callable type of the edge iteration function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Offset pointers of the adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Indices of the adjacency list </td></tr>
    <tr><td class="paramname">f</td><td>Callable function to be applied to each edge with signature <code>void(TIndex i, TIndex j,
TIndex k)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1853b76a08732c08e8dcd42169ce8f0e" name="a1853b76a08732c08e8dcd42169ce8f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1853b76a08732c08e8dcd42169ce8f0e">&#9670;&#160;</a></span>GreedyColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedPtr, class TDerivedAdj, int NC = 128, std::integral TIndex = typename TDerivedPtr::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::GreedyColor </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedPtr &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedAdj &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac26166ca4b423603403a335c47224b45">EGreedyColorOrderingStrategy</a></td>          <td class="paramname"><span class="paramname"><em>eOrderingStrategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac26166ca4b423603403a335c47224b45a2ddb2b46f6e9567f5a44c430f996f536">EGreedyColorOrderingStrategy::LargestDegree</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae94ec1f32cf36a23c873b18b0400645">EGreedyColorSelectionStrategy</a></td>          <td class="paramname"><span class="paramname"><em>eSelectionStrategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aae94ec1f32cf36a23c873b18b0400645a98f052a90774dc8335e422b6076b9da3">EGreedyColorSelectionStrategy::LeastUsed</a></span>&#160;) -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greedy graph coloring algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedPtr</td><td>Eigen dense expression for offset pointers of the adjacency list </td></tr>
    <tr><td class="paramname">TDerivedAdj</td><td>Eigen dense expression for indices of the adjacency list </td></tr>
    <tr><td class="paramname">NC</td><td>Color palette capacity </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type for vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Offset pointers array of the adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Indices array of the adjacency list </td></tr>
    <tr><td class="paramname">eOrderingStrategy</td><td>Vertex visiting order strategy </td></tr>
    <tr><td class="paramname">eSelectionStrategy</td><td>Color selection strategy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>|# vertices|</code> array mapping vertices to their associated color </dd></dl>

</div>
</div>
<a id="a4bf3f0177c97f73f1ff4de2f336e7b6a" name="a4bf3f0177c97f73f1ff4de2f336e7b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3f0177c97f73f1ff4de2f336e7b6a">&#9670;&#160;</a></span>ListOfListsToAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex = Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::ListOfListsToAdjacency </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; TIndex &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>lil</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency list in compressed sparse format from an input adjacency list in list of lists format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lil</td><td>Input adjacency list in list of lists format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the offset pointers and indices of the adjacency list </dd></dl>

</div>
</div>
<a id="a6c2db92c83d3d9964a4d5170a349238c" name="a6c2db92c83d3d9964a4d5170a349238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2db92c83d3d9964a4d5170a349238c">&#9670;&#160;</a></span>MapToAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedP, std::integral TIndex = typename TDerivedP::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MapToAdjacency </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedP &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>&#160;) -&gt; std::tuple&lt;Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;, Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency list in compressed sparse format from a map p s.t. p(i) is the index of the vertex adjacent to i. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedP</td><td>Type of input map </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Input map </td></tr>
    <tr><td class="paramname">n</td><td>Number of vertices in the graph. If not provided (i.e. n &lt; 0), it is inferred from the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the offset pointers and indices of the adjacency list </dd></dl>

</div>
</div>
<a id="aeeb8189ed58658d208ade64f5daf66d0" name="aeeb8189ed58658d208ade64f5daf66d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb8189ed58658d208ade64f5daf66d0">&#9670;&#160;</a></span>MatrixToAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MatrixToAdjacency </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the offset and indices arrays of an input adjacency matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedA</td><td>Type of input adjacency matrix </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the offset pointers and indices of the adjacency matrix </dd></dl>

</div>
</div>
<a id="a69e4b9a72106fc61acfdf7a99d01ac13" name="a69e4b9a72106fc61acfdf7a99d01ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e4b9a72106fc61acfdf7a99d01ac13">&#9670;&#160;</a></span>MatrixToWeightedAdjacency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedA, class TScalar = typename TDerivedA::Scalar, std::integral TIndex = typename TDerivedA::StorageIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MatrixToWeightedAdjacency </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; TDerivedA &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency list in compressed sparse format from an input adjacency matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedA</td><td>Type of input adjacency matrix </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the graph edge weights </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Input adjacency matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple of the offset pointers, indices, and weights of the adjacency matrix </dd></dl>

</div>
</div>
<a id="a92708086f95b45eca0c636ee7e4a9864" name="a92708086f95b45eca0c636ee7e4a9864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92708086f95b45eca0c636ee7e4a9864">&#9670;&#160;</a></span>MeshAdjacencyMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedE, class TDerivedW, common::CIndex TIndex = typename TDerivedE::Scalar, common::CArithmetic TScalar = typename TDerivedW::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MeshAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedW &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>nNodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bVertexToElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bHasDuplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) -&gt; Eigen::SparseMatrix&lt;TScalar, Eigen::ColMajor, TIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency matrix from mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression for mesh elements </td></tr>
    <tr><td class="paramname">TDerivedW</td><td>Eigen dense expression for element-vertex weights </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of indices used in element array </td></tr>
    <tr><td class="paramname">TScalar</td><td>Type of weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td><code>|# nodes per element|x|# elements|</code> array of element indices </td></tr>
    <tr><td class="paramname">w</td><td><code>|# nodes per element|x|# elements|</code> array of element-vertex weights </td></tr>
    <tr><td class="paramname">nNodes</td><td>Number of nodes in the mesh. If <code>nNodes &lt; 1</code>, the number of nodes is inferred from E. </td></tr>
    <tr><td class="paramname">bVertexToElement</td><td>If true, the adjacency matrix maps vertices to elements, rather than elements to vertices </td></tr>
    <tr><td class="paramname">bHasDuplicates</td><td>If true, duplicate entries in the input mesh will be handled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjacency matrix of requested mesh connectivity </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>E.rows() == w.rows()</code> and <code>E.cols() == w.cols()</code> </dd></dl>

</div>
</div>
<a id="a2ef0f0cc7fa6bd2ba1b423e21c40e5f4" name="a2ef0f0cc7fa6bd2ba1b423e21c40e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef0f0cc7fa6bd2ba1b423e21c40e5f4">&#9670;&#160;</a></span>MeshAdjacencyMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MeshAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>nNodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bVertexToElement</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bHasDuplicates</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) -&gt; Eigen::SparseMatrix&lt;TIndex, Eigen::ColMajor, TIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct adjacency matrix from mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression for mesh elements </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of indices used in element array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td><code>|# nodes per element|x|# elements|</code> array of element indices </td></tr>
    <tr><td class="paramname">nNodes</td><td>Number of nodes in the mesh. If <code>nNodes &lt; 1</code>, the number of nodes is inferred from E. </td></tr>
    <tr><td class="paramname">bVertexToElement</td><td>If true, the adjacency matrix maps vertices to elements, rather than </td></tr>
    <tr><td class="paramname">bHasDuplicates</td><td>If true, duplicate entries in the input mesh will be handled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjacency matrix of requested mesh connectivity </dd></dl>

</div>
</div>
<a id="aa27c11cf51026074641f54fc63afc13a" name="aa27c11cf51026074641f54fc63afc13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27c11cf51026074641f54fc63afc13a">&#9670;&#160;</a></span>MeshDualGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MeshDualGraph </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>nNodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7cb7c7df4fe22b56ba7f39c144f8aac9">EMeshDualGraphOptions</a></td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">EMeshDualGraphOptions::All</span>&#160;) -&gt; Eigen::SparseMatrix&lt;TIndex, Eigen::ColMajor, TIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct dual graph of input mesh, i.e. the graph of adjacent elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression for mesh elements </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of indices used in element array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td><code>|# nodes per element|x|# elements|</code> array of element indices </td></tr>
    <tr><td class="paramname">nNodes</td><td>Number of nodes in the mesh. If <code>nNodes &lt; 1</code>, the number of nodes is inferred from E. </td></tr>
    <tr><td class="paramname">opts</td><td>Adjacency types to keep in the dual graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dual graph of the input mesh </dd></dl>

</div>
</div>
<a id="a9bfc67838583486d2d0d3b939242007a" name="a9bfc67838583486d2d0d3b939242007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfc67838583486d2d0d3b939242007a">&#9670;&#160;</a></span>MeshPrimalGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedE, common::CIndex TIndex = typename TDerivedE::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::graph::MeshPrimalGraph </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedE &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>nNodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">TIndex(-1)</span>&#160;) -&gt; Eigen::SparseMatrix&lt;TIndex, Eigen::ColMajor, TIndex&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct primal graph of input mesh, i.e. the graph of adjacent vertices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedE</td><td>Eigen dense expression for mesh elements </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of indices used in element array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td><code>|# nodes per element|x|# elements|</code> array of element indices </td></tr>
    <tr><td class="paramname">nNodes</td><td>Number of nodes in the mesh. If <code>nNodes &lt; 1</code>, the number of nodes is inferred from E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Primal graph of the input mesh </dd></dl>

</div>
</div>
<a id="a354a43676f2a845657e69033d1a7cbee" name="a354a43676f2a845657e69033d1a7cbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354a43676f2a845657e69033d1a7cbee">&#9670;&#160;</a></span>Partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PBAT_API <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> pbat::graph::Partition </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="../../d0/d7c/namespacepbat.html#a41114f74a5108dd666ed3daa33497f30">IndexVectorX</a> const &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>wadj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6">Index</a></td>          <td class="paramname"><span class="paramname"><em>nPartitions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html">PartitioningOptions</a></td>          <td class="paramname"><span class="paramname"><em>opts</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d9/d2e/structpbat_1_1graph_1_1_partitioning_options.html">PartitioningOptions</a>{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition input graph. </p>
<p>Internally delegates to METIS <a class="el" href="../../d0/de3/citelist.html#CITEREF_karypis1997metis">[7]</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Offset pointers of adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Indices of adjacency list </td></tr>
    <tr><td class="paramname">wadj</td><td>Edge weights of adjacency list </td></tr>
    <tr><td class="paramname">nPartitions</td><td>Number of desired partitions </td></tr>
    <tr><td class="paramname">opts</td><td>Partitioning options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>|# vertices|</code> array p of partition indices (i.e. p[i] = partition of vertex i) </dd></dl>

</div>
</div>
<a id="a7c2c0accc9a57ed6650ef2bb957f7113" name="a7c2c0accc9a57ed6650ef2bb957f7113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2c0accc9a57ed6650ef2bb957f7113">&#9670;&#160;</a></span>RemoveEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedPtr, class TDerivedAdj, class TIndex = typename TDerivedPtr::Scalar, class Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::graph::RemoveEdges </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedPtr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedAdj &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>adj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>fShouldDeleteEdge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place removal of edges from the adjacency list in compressed sparse format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedPtr</td><td>Eigen dense expression of the offset pointers of the adjacency list </td></tr>
    <tr><td class="paramname">TDerivedAdj</td><td>Eigen dense expression of the indices of the adjacency list </td></tr>
    <tr><td class="paramname">TIndex</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> type of the graph vertices </td></tr>
    <tr><td class="paramname">Func</td><td>Callable type of the edge removal function with signature <code>bool(TIndex i, TIndex j)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Offset pointers of the adjacency list </td></tr>
    <tr><td class="paramname">adj</td><td>Indices of the adjacency list </td></tr>
    <tr><td class="paramname">fShouldDeleteEdge</td><td>Callable function to determine if an edge should be removed with signature <code>bool(TIndex i, TIndex j)</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d7c/namespacepbat.html">pbat</a></li><li class="navelem"><a class="el" href="../../d9/dc9/namespacepbat_1_1graph.html">graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
