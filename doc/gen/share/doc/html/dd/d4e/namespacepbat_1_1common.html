<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.13.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PhysicsBasedAnimationToolkit: pbat::common Namespace Reference</title>
  <link rel="icon" href="../../entei.icon.png" type="image/x-icon" />
  <link href="../../tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="../../jquery.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
  <!-- BEGIN Doxygen Awesome -->
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
  </script>
  <script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeTabs.init()
  </script>
  <!-- END Doxygen Awesome -->
  <link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
  <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="../../pbat.svg"  /></td>
              <td id="projectalign">
                <div id="projectname">PhysicsBasedAnimationToolkit<span
                    id="projectnumber">&#160;0.0.10</span>
                </div>
                <div id="projectbrief">Cross-platform C++20 library of algorithms and data structures commonly used in computer graphics research on physically-based simulation.</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d4e/namespacepbat_1_1common.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pbat::common Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Common functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d3c/classpbat_1_1common_1_1_binary_radix_tree.html">BinaryRadixTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary radix tree implementation.  <a href="../../d1/d3c/classpbat_1_1common_1_1_binary_radix_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d29/classpbat_1_1common_1_1_brute_set.html">BruteSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size brute-force set implementation.  <a href="../../d6/d29/classpbat_1_1common_1_1_brute_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd7/classpbat_1_1common_1_1_heap.html">Heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size max heap.  <a href="../../d0/dd7/classpbat_1_1common_1_1_heap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structpbat_1_1common_1_1_overloaded.html">Overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++20 feature to allow multiple inheritance of operator() for lambdas.  <a href="../../da/dbf/structpbat_1_1common_1_1_overloaded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de7/classpbat_1_1common_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size queue implementation.  <a href="../../dc/de7/classpbat_1_1common_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfe/classpbat_1_1common_1_1_stack.html">Stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size stack implementation.  <a href="../../d2/dfe/classpbat_1_1common_1_1_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d04/conceptpbat_1_1common_1_1_c_arithmetic.html">CArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for arithmetic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc2/conceptpbat_1_1common_1_1_c_index.html">CIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for integral types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dba/conceptpbat_1_1common_1_1_c_floating_point.html">CFloatingPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for floating-point types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d32/conceptpbat_1_1common_1_1_c_index_range.html">CIndexRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of integer types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d2e/conceptpbat_1_1common_1_1_c_contiguous_index_range.html">CContiguousIndexRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous range of integer types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5a/conceptpbat_1_1common_1_1_c_arithmetic_range.html">CArithmeticRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of arithmetic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d15/conceptpbat_1_1common_1_1_c_contiguous_arithmetic_range.html">CContiguousArithmeticRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous range of arithmetic types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d54/conceptpbat_1_1common_1_1_c_contiguous_arithmetic_matrix_range.html">CContiguousArithmeticMatrixRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of Eigen fixed-size matrix types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0439629eeba53371a1d5b2a2f8d5aa0" id="r_ab0439629eeba53371a1d5b2a2f8d5aa0"><td class="memTemplParams" colspan="2">template&lt;std::integral TIndex, class FLess&gt; </td></tr>
<tr class="memitem:ab0439629eeba53371a1d5b2a2f8d5aa0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0439629eeba53371a1d5b2a2f8d5aa0">ArgSort</a> (TIndex n, FLess less) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:ab0439629eeba53371a1d5b2a2f8d5aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the indices that would sort an array.  <br /></td></tr>
<tr class="separator:ab0439629eeba53371a1d5b2a2f8d5aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480d692365ed05e9ec79bc3f95e5d36d" id="r_a480d692365ed05e9ec79bc3f95e5d36d"><td class="memTemplParams" colspan="2">template&lt;class... Ts, class F&gt; </td></tr>
<tr class="memitem:a480d692365ed05e9ec79bc3f95e5d36d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a480d692365ed05e9ec79bc3f95e5d36d">ForTypes</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a480d692365ed05e9ec79bc3f95e5d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over types.  <br /></td></tr>
<tr class="separator:a480d692365ed05e9ec79bc3f95e5d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d280ddd3b75d1e8391a5c4c30f72ac" id="r_ac5d280ddd3b75d1e8391a5c4c30f72ac"><td class="memTemplParams" colspan="2">template&lt;auto... Xs, class F&gt; </td></tr>
<tr class="memitem:ac5d280ddd3b75d1e8391a5c4c30f72ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5d280ddd3b75d1e8391a5c4c30f72ac">ForValues</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ac5d280ddd3b75d1e8391a5c4c30f72ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over values.  <br /></td></tr>
<tr class="separator:ac5d280ddd3b75d1e8391a5c4c30f72ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51e60890ee897ee1a9932b6899f81a7" id="r_ad51e60890ee897ee1a9932b6899f81a7"><td class="memTemplParams" colspan="2">template&lt;auto Begin, auto End, typename F&gt; </td></tr>
<tr class="memitem:ad51e60890ee897ee1a9932b6899f81a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad51e60890ee897ee1a9932b6899f81a7">ForRange</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ad51e60890ee897ee1a9932b6899f81a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time for loop over a range of values.  <br /></td></tr>
<tr class="separator:ad51e60890ee897ee1a9932b6899f81a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3a7623fd3f1c50b986fd6271f85865" id="r_a1e3a7623fd3f1c50b986fd6271f85865"><td class="memTemplParams" colspan="2">template&lt;std::random_access_iterator TWorkBegin, std::random_access_iterator TWorkEnd, std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, class FKey, class T = typename std::iterator_traits&lt;TValuesBegin&gt;::value_type, class TKey = typename std::invoke_result_t&lt;FKey, T&gt;&gt; </td></tr>
<tr class="memitem:a1e3a7623fd3f1c50b986fd6271f85865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e3a7623fd3f1c50b986fd6271f85865">CountingSort</a> (TWorkBegin wb, TWorkEnd we, TValuesBegin vb, TValuesEnd ve, TKey keyMin=std::numeric_limits&lt; TKey &gt;::max(), FKey fKey=[](T const &amp;key) { return key;})</td></tr>
<tr class="memdesc:a1e3a7623fd3f1c50b986fd6271f85865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counting sort.  <br /></td></tr>
<tr class="separator:a1e3a7623fd3f1c50b986fd6271f85865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b09c67f2bca23da304df358e87ebbbf" id="r_a3b09c67f2bca23da304df358e87ebbbf"><td class="memTemplParams" colspan="2">template&lt;std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, std::random_access_iterator TWorkBegin, class FKey&gt; </td></tr>
<tr class="memitem:a3b09c67f2bca23da304df358e87ebbbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b09c67f2bca23da304df358e87ebbbf">PrefixSumFromSortedKeys</a> (TValuesBegin vb, TValuesEnd ve, TWorkBegin wb, FKey fKey)</td></tr>
<tr class="separator:a3b09c67f2bca23da304df358e87ebbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed005ac4d92e56497095bc23c46ac0" id="r_adbed005ac4d92e56497095bc23c46ac0"><td class="memTemplParams" colspan="2">template&lt;CContiguousArithmeticRange R&gt; </td></tr>
<tr class="memitem:adbed005ac4d92e56497095bc23c46ac0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbed005ac4d92e56497095bc23c46ac0">ToEigen</a> (R &amp;&amp;r) -&gt; Eigen::Map&lt; Eigen::Vector&lt; std::ranges::range_value_t&lt; R &gt;, Eigen::Dynamic &gt; const &gt;</td></tr>
<tr class="memdesc:adbed005ac4d92e56497095bc23c46ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a range of scalars to an eigen vector of such scalars.  <br /></td></tr>
<tr class="separator:adbed005ac4d92e56497095bc23c46ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd49b77d32cd35798788ce543e960484" id="r_abd49b77d32cd35798788ce543e960484"><td class="memTemplParams" colspan="2">template&lt;std::ranges::random_access_range R&gt; </td></tr>
<tr class="memitem:abd49b77d32cd35798788ce543e960484"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd49b77d32cd35798788ce543e960484">Slice</a> (R &amp;&amp;r)</td></tr>
<tr class="memdesc:abd49b77d32cd35798788ce543e960484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice view over a range for Eigen advanced indexing.  <br /></td></tr>
<tr class="separator:abd49b77d32cd35798788ce543e960484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d9ddd0a8d228a4400bd6966646797" id="r_a885d9ddd0a8d228a4400bd6966646797"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a885d9ddd0a8d228a4400bd6966646797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a885d9ddd0a8d228a4400bd6966646797">HashCombineAccumulate</a> (std::size_t &amp;seed, T const &amp;val)</td></tr>
<tr class="memdesc:a885d9ddd0a8d228a4400bd6966646797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementally combine hash values of multiple arguments.  <br /></td></tr>
<tr class="separator:a885d9ddd0a8d228a4400bd6966646797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f72b536fe192b8f0c7be6ccc1e2acaa" id="r_a2f72b536fe192b8f0c7be6ccc1e2acaa"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a2f72b536fe192b8f0c7be6ccc1e2acaa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2f72b536fe192b8f0c7be6ccc1e2acaa">HashCombine</a> (Types const &amp;... args)</td></tr>
<tr class="memdesc:a2f72b536fe192b8f0c7be6ccc1e2acaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine hash values of multiple arguments.  <br /></td></tr>
<tr class="separator:a2f72b536fe192b8f0c7be6ccc1e2acaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa534e6308de7615c6e5015db7c9b3842" id="r_aa534e6308de7615c6e5015db7c9b3842"><td class="memTemplParams" colspan="2">template&lt;CIndexRange R, std::integral TIndex = std::ranges::range_value_t&lt;R&gt;&gt; </td></tr>
<tr class="memitem:aa534e6308de7615c6e5015db7c9b3842"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa534e6308de7615c6e5015db7c9b3842">CumSum</a> (R &amp;&amp;sizes) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:aa534e6308de7615c6e5015db7c9b3842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative sum of a range of integers.  <br /></td></tr>
<tr class="separator:aa534e6308de7615c6e5015db7c9b3842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4629d86e482f931387e87da8c62833" id="r_a3d4629d86e482f931387e87da8c62833"><td class="memTemplParams" colspan="2">template&lt;std::integral TIndex&gt; </td></tr>
<tr class="memitem:a3d4629d86e482f931387e87da8c62833"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d4629d86e482f931387e87da8c62833">Counts</a> (auto begin, auto end, TIndex ncounts) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a3d4629d86e482f931387e87da8c62833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of each integer in a contiguous range.  <br /></td></tr>
<tr class="separator:a3d4629d86e482f931387e87da8c62833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73daad5a50f0fab5698ca86f8c0eaecd" id="r_a73daad5a50f0fab5698ca86f8c0eaecd"><td class="memTemplParams" colspan="2">template&lt;std::integral TIndex&gt; </td></tr>
<tr class="memitem:a73daad5a50f0fab5698ca86f8c0eaecd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73daad5a50f0fab5698ca86f8c0eaecd">Shuffle</a> (TIndex begin, TIndex end) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a73daad5a50f0fab5698ca86f8c0eaecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly shuffle a range of integers.  <br /></td></tr>
<tr class="separator:a73daad5a50f0fab5698ca86f8c0eaecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2205778d4efe327d2dd564ce005fb944" id="r_a2205778d4efe327d2dd564ce005fb944"><td class="memTemplParams" colspan="2">template&lt;std::integral TIndexB, std::integral TIndexE, class Func, class TIndex = std::common_type_t&lt;TIndexB, TIndexE&gt;&gt; </td></tr>
<tr class="memitem:a2205778d4efe327d2dd564ce005fb944"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2205778d4efe327d2dd564ce005fb944">Filter</a> (TIndexB begin, TIndexE end, Func &amp;&amp;f) -&gt; Eigen::Vector&lt; TIndex, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a2205778d4efe327d2dd564ce005fb944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a range of integers based on a predicate function.  <br /></td></tr>
<tr class="separator:a2205778d4efe327d2dd564ce005fb944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aca25135141e42b841833f2b56df40" id="r_af5aca25135141e42b841833f2b56df40"><td class="memTemplParams" colspan="2">template&lt;class TDerivedX, class TDerivedR, class TScalar = typename TDerivedX::Scalar, std::integral TIndex = typename TDerivedR::Scalar&gt; </td></tr>
<tr class="memitem:af5aca25135141e42b841833f2b56df40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5aca25135141e42b841833f2b56df40">Repeat</a> (Eigen::DenseBase&lt; TDerivedX &gt; const &amp;x, Eigen::DenseBase&lt; TDerivedR &gt; const &amp;r) -&gt; Eigen::Vector&lt; TScalar, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:af5aca25135141e42b841833f2b56df40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats elements of a vector according to a repetition vector.  <br /></td></tr>
<tr class="separator:af5aca25135141e42b841833f2b56df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc95feadc1500d37d8ba114984549fbc" id="r_afc95feadc1500d37d8ba114984549fbc"><td class="memItemLeft" align="right" valign="top"><a id="afc95feadc1500d37d8ba114984549fbc" name="afc95feadc1500d37d8ba114984549fbc"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Modulo</b> (auto a, auto b)</td></tr>
<tr class="separator:afc95feadc1500d37d8ba114984549fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913b041f0ec99d20819d1d6a598539a" id="r_a8913b041f0ec99d20819d1d6a598539a"><td class="memTemplParams" colspan="2">template&lt;class FVisit, class FChild, class TIndex = Index, auto N = 2, auto kStackDepth = 64&gt; </td></tr>
<tr class="memitem:a8913b041f0ec99d20819d1d6a598539a"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8913b041f0ec99d20819d1d6a598539a">TraverseNAryTreePseudoPreOrder</a> (FVisit fVisit, FChild fChild, TIndex root=0)</td></tr>
<tr class="memdesc:a8913b041f0ec99d20819d1d6a598539a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-order traversal over an n-ary tree starting from root.  <br /></td></tr>
<tr class="separator:a8913b041f0ec99d20819d1d6a598539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92062ff78c3305160190e802ecabb21b" id="r_a92062ff78c3305160190e802ecabb21b"><td class="memTemplParams" colspan="2">template&lt;class FVisit, class FChild, class TIndex = Index, auto N = 2, auto kStackDepth = 64&gt; </td></tr>
<tr class="memitem:a92062ff78c3305160190e802ecabb21b"><td class="memTemplItemLeft" align="right" valign="top">PBAT_HOST_DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92062ff78c3305160190e802ecabb21b">TraverseNAryTreePseudoPostOrder</a> (FVisit fVisit, FChild fChild, TIndex root=0)</td></tr>
<tr class="memdesc:a92062ff78c3305160190e802ecabb21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-order traversal over an n-ary tree starting from root.  <br /></td></tr>
<tr class="separator:a92062ff78c3305160190e802ecabb21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119548543d25cdee436e0ebc87d8c2e" id="r_a6119548543d25cdee436e0ebc87d8c2e"><td class="memTemplParams" colspan="2">template&lt;std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, std::random_access_iterator TPermutationBegin&gt; </td></tr>
<tr class="memitem:a6119548543d25cdee436e0ebc87d8c2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6119548543d25cdee436e0ebc87d8c2e">Permute</a> (TValuesBegin vb, TValuesEnd ve, TPermutationBegin pb)</td></tr>
<tr class="memdesc:a6119548543d25cdee436e0ebc87d8c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the values in-place according to the permutation.  <br /></td></tr>
<tr class="separator:a6119548543d25cdee436e0ebc87d8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common functionality. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab0439629eeba53371a1d5b2a2f8d5aa0" name="ab0439629eeba53371a1d5b2a2f8d5aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0439629eeba53371a1d5b2a2f8d5aa0">&#9670;&#160;</a></span>ArgSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral TIndex, class FLess&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::ArgSort </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLess</td>          <td class="paramname"><span class="paramname"><em>less</em></span>&#160;) -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the indices that would sort an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Coefficient type of returned vector </td></tr>
    <tr><td class="paramname">FLess</td><td>Callable with signature <code>bool(TIndex, TIndex)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements </td></tr>
    <tr><td class="paramname">less</td><td>Less-than comparison function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>|n|</code> array of indices that would sort the input array </dd></dl>

</div>
</div>
<a id="a1e3a7623fd3f1c50b986fd6271f85865" name="a1e3a7623fd3f1c50b986fd6271f85865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3a7623fd3f1c50b986fd6271f85865">&#9670;&#160;</a></span>CountingSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::random_access_iterator TWorkBegin, std::random_access_iterator TWorkEnd, std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, class FKey, class T = typename std::iterator_traits&lt;TValuesBegin&gt;::value_type, class TKey = typename std::invoke_result_t&lt;FKey, T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::CountingSort </td>
          <td>(</td>
          <td class="paramtype">TWorkBegin</td>          <td class="paramname"><span class="paramname"><em>wb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TWorkEnd</td>          <td class="paramname"><span class="paramname"><em>we</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValuesBegin</td>          <td class="paramname"><span class="paramname"><em>vb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValuesEnd</td>          <td class="paramname"><span class="paramname"><em>ve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKey</td>          <td class="paramname"><span class="paramname"><em>keyMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;TKey&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FKey</td>          <td class="paramname"><span class="paramname"><em>fKey</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[](T&#160;const&amp;&#160;key)&#160;{&#160;return&#160;key;&#160;}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counting sort. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TWorkBegin</td><td>Iterator type to the beginning of the work array </td></tr>
    <tr><td class="paramname">TWorkEnd</td><td>Iterator type to the end of the work array </td></tr>
    <tr><td class="paramname">TValuesBegin</td><td>Iterator type to the beginning of the values </td></tr>
    <tr><td class="paramname">TValuesEnd</td><td>Iterator type to the end of the values </td></tr>
    <tr><td class="paramname">FKey</td><td>Key accessor callable with signature <code>TKey(T)</code> </td></tr>
    <tr><td class="paramname">T</td><td>Value type </td></tr>
    <tr><td class="paramname">TKey</td><td>Key type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wb</td><td>Iterator to the beginning of the work array </td></tr>
    <tr><td class="paramname">we</td><td>Iterator to the end of the work array </td></tr>
    <tr><td class="paramname">vb</td><td>Iterator to the beginning of values </td></tr>
    <tr><td class="paramname">ve</td><td>Iterator to the end of values </td></tr>
    <tr><td class="paramname">keyMin</td><td>Minimum key value </td></tr>
    <tr><td class="paramname">fKey</td><td>Key accessor callable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>*(wb+i) == 0</code> for all <code>i in [0, std::distance(wb,we))</code> </dd></dl>

</div>
</div>
<a id="a3d4629d86e482f931387e87da8c62833" name="a3d4629d86e482f931387e87da8c62833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4629d86e482f931387e87da8c62833">&#9670;&#160;</a></span>Counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral TIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::Counts </td>
          <td>(</td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>ncounts</em></span>&#160;) -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of occurrences of each integer in a contiguous range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of counts </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Range begin </td></tr>
    <tr><td class="paramname">end</td><td>Range end (exclusive) </td></tr>
    <tr><td class="paramname">ncounts</td><td>Upper bound on values in range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Counts of each integer in the range </dd></dl>

</div>
</div>
<a id="aa534e6308de7615c6e5015db7c9b3842" name="aa534e6308de7615c6e5015db7c9b3842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa534e6308de7615c6e5015db7c9b3842">&#9670;&#160;</a></span>CumSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CIndexRange R, std::integral TIndex = std::ranges::range_value_t&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::CumSum </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span></td><td>)</td>
          <td> -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative sum of a range of integers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Integer range type </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Range of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of the range </dd></dl>

</div>
</div>
<a id="a2205778d4efe327d2dd564ce005fb944" name="a2205778d4efe327d2dd564ce005fb944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2205778d4efe327d2dd564ce005fb944">&#9670;&#160;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral TIndexB, std::integral TIndexE, class Func, class TIndex = std::common_type_t&lt;TIndexB, TIndexE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::Filter </td>
          <td>(</td>
          <td class="paramtype">TIndexB</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndexE</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;) -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a range of integers based on a predicate function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndexB</td><td>Type of the beginning index </td></tr>
    <tr><td class="paramname">TIndexE</td><td>Type of the ending index </td></tr>
    <tr><td class="paramname">Func</td><td>Predicate function type (TIndex -&gt; bool) </td></tr>
    <tr><td class="paramname">TIndex</td><td>Common type of the indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start of the range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>End of the range (exclusive) </td></tr>
    <tr><td class="paramname">f</td><td>Predicate function to filter the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filtered range of integers </dd></dl>

</div>
</div>
<a id="ad51e60890ee897ee1a9932b6899f81a7" name="ad51e60890ee897ee1a9932b6899f81a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51e60890ee897ee1a9932b6899f81a7">&#9670;&#160;</a></span>ForRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto Begin, auto End, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::ForRange </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over a range of values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Begin</td><td>Starting loop index </td></tr>
    <tr><td class="paramname">End</td><td>Ending loop index (exclusive) </td></tr>
    <tr><td class="paramname">F</td><td>Callable with signature <code>void operator()&lt;decltype(Begin)&gt;()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function object to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a480d692365ed05e9ec79bc3f95e5d36d" name="a480d692365ed05e9ec79bc3f95e5d36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480d692365ed05e9ec79bc3f95e5d36d">&#9670;&#160;</a></span>ForTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::ForTypes </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>Types to loop over </td></tr>
    <tr><td class="paramname">F</td><td>Callable with signature <code>void operator()&lt;T&gt;()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function object to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5d280ddd3b75d1e8391a5c4c30f72ac" name="ac5d280ddd3b75d1e8391a5c4c30f72ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d280ddd3b75d1e8391a5c4c30f72ac">&#9670;&#160;</a></span>ForValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... Xs, class F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::ForValues </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time for loop over values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Xs</td><td>Values to loop over </td></tr>
    <tr><td class="paramname">F</td><td>Callable with signature <code>void operator()&lt;X&gt;()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function object to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f72b536fe192b8f0c7be6ccc1e2acaa" name="a2f72b536fe192b8f0c7be6ccc1e2acaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f72b536fe192b8f0c7be6ccc1e2acaa">&#9670;&#160;</a></span>HashCombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pbat::common::HashCombine </td>
          <td>(</td>
          <td class="paramtype">Types const &amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine hash values of multiple arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>Hashable types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value </dd></dl>

</div>
</div>
<a id="a885d9ddd0a8d228a4400bd6966646797" name="a885d9ddd0a8d228a4400bd6966646797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885d9ddd0a8d228a4400bd6966646797">&#9670;&#160;</a></span>HashCombineAccumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::HashCombineAccumulate </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incrementally combine hash values of multiple arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Hashable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Starting hash value </td></tr>
    <tr><td class="paramname">val</td><td>Value to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6119548543d25cdee436e0ebc87d8c2e" name="a6119548543d25cdee436e0ebc87d8c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119548543d25cdee436e0ebc87d8c2e">&#9670;&#160;</a></span>Permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, std::random_access_iterator TPermutationBegin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::Permute </td>
          <td>(</td>
          <td class="paramtype">TValuesBegin</td>          <td class="paramname"><span class="paramname"><em>vb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValuesEnd</td>          <td class="paramname"><span class="paramname"><em>ve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPermutationBegin</td>          <td class="paramname"><span class="paramname"><em>pb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permute the values in-place according to the permutation. </p>
<p>Taken from <a href="https://stackoverflow.com/a/60917997/8239925">SO</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValuesBegin</td><td>Iterator type to the beginning of the values </td></tr>
    <tr><td class="paramname">TValuesEnd</td><td>Iterator type to the end of the values </td></tr>
    <tr><td class="paramname">TPermutationBegin</td><td>Iterator type to the beginning of the permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vb</td><td>Iterator to the beginning of values </td></tr>
    <tr><td class="paramname">ve</td><td>Iterator to the end of values </td></tr>
    <tr><td class="paramname">pb</td><td>Iterator to the beginning of permutation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The permutation is modified in-place for the duration of the function, but is restored to its original state before returning.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The permutation referenced by <code>pb</code> is un-modified. </dd>
<dd>
The values referenced by <code>[vb, ve)</code> are permuted according to the permutation. </dd></dl>

</div>
</div>
<a id="a3b09c67f2bca23da304df358e87ebbbf" name="a3b09c67f2bca23da304df358e87ebbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b09c67f2bca23da304df358e87ebbbf">&#9670;&#160;</a></span>PrefixSumFromSortedKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::random_access_iterator TValuesBegin, std::random_access_iterator TValuesEnd, std::random_access_iterator TWorkBegin, class FKey&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pbat::common::PrefixSumFromSortedKeys </td>
          <td>(</td>
          <td class="paramtype">TValuesBegin</td>          <td class="paramname"><span class="paramname"><em>vb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValuesEnd</td>          <td class="paramname"><span class="paramname"><em>ve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TWorkBegin</td>          <td class="paramname"><span class="paramname"><em>wb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FKey</td>          <td class="paramname"><span class="paramname"><em>fKey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FKey</td><td></td></tr>
    <tr><td class="paramname">TValuesBegin</td><td></td></tr>
    <tr><td class="paramname">TValuesEnd</td><td></td></tr>
    <tr><td class="paramname">TWorkBegin</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vb</td><td></td></tr>
    <tr><td class="paramname">ve</td><td></td></tr>
    <tr><td class="paramname">wb</td><td></td></tr>
    <tr><td class="paramname">fKey</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5aca25135141e42b841833f2b56df40" name="af5aca25135141e42b841833f2b56df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5aca25135141e42b841833f2b56df40">&#9670;&#160;</a></span>Repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TDerivedX, class TDerivedR, class TScalar = typename TDerivedX::Scalar, std::integral TIndex = typename TDerivedR::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::Repeat </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedX &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; TDerivedR &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;) -&gt; Eigen::Vector&lt;TScalar, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeats elements of a vector according to a repetition vector. </p>
<p>Similar to <a href="https://numpy.org/doc/stable/reference/generated/numpy.repeat.html">numpy.repeat</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDerivedX</td><td>Eigen dense expression of the input vector </td></tr>
    <tr><td class="paramname">TDerivedR</td><td>Eigen dense expression of the repetition vector </td></tr>
    <tr><td class="paramname">TScalar</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#adb88e81cb91ca31d044300522f800fd2" title="Scalar type.">Scalar</a> type of the input vector </td></tr>
    <tr><td class="paramname">TIndex</td><td>Integer type of the repetition vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Values to repeat </td></tr>
    <tr><td class="paramname">r</td><td>Repetition vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/d7c/namespacepbat.html#a682b4fdd1bb92ef64f406a2a356ee8e8" title="Fixed-size vector type.">Vector</a> with repeated elements </dd></dl>

</div>
</div>
<a id="a73daad5a50f0fab5698ca86f8c0eaecd" name="a73daad5a50f0fab5698ca86f8c0eaecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73daad5a50f0fab5698ca86f8c0eaecd">&#9670;&#160;</a></span>Shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral TIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::Shuffle </td>
          <td>(</td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;) -&gt; Eigen::Vector&lt;TIndex, Eigen::Dynamic&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly shuffle a range of integers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start of the range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>End of the range (exclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shuffled range of integers </dd></dl>

</div>
</div>
<a id="abd49b77d32cd35798788ce543e960484" name="abd49b77d32cd35798788ce543e960484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd49b77d32cd35798788ce543e960484">&#9670;&#160;</a></span>Slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::random_access_range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::Slice </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice view over a range for Eigen advanced indexing. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type with size(), operator[] and operator() for Eigen advanced indexing </dd></dl>

</div>
</div>
<a id="adbed005ac4d92e56497095bc23c46ac0" name="adbed005ac4d92e56497095bc23c46ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbed005ac4d92e56497095bc23c46ac0">&#9670;&#160;</a></span>ToEigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CContiguousArithmeticRange R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pbat::common::ToEigen </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> -&gt; Eigen::Map&lt;Eigen::Vector&lt;std::ranges::range_value_t&lt;R&gt;, Eigen::Dynamic&gt; const&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a range of scalars to an eigen vector of such scalars. </p>
<p>Map a range of scalar matrices to an eigen vector of such scalars.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen vector adaptor</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen matrix adaptor </dd></dl>

</div>
</div>
<a id="a92062ff78c3305160190e802ecabb21b" name="a92062ff78c3305160190e802ecabb21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92062ff78c3305160190e802ecabb21b">&#9670;&#160;</a></span>TraverseNAryTreePseudoPostOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FVisit, class FChild, class TIndex = Index, auto N = 2, auto kStackDepth = 64&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE void pbat::common::TraverseNAryTreePseudoPostOrder </td>
          <td>(</td>
          <td class="paramtype">FVisit</td>          <td class="paramname"><span class="paramname"><em>fVisit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post-order traversal over an n-ary tree starting from root. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FVisit</td><td>Function to visit a node </td></tr>
    <tr><td class="paramname">FChild</td><td>Function to get the child of a node </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">N</td><td>Number of children per node </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack. The actual stack depth will be N*kStackDepth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fVisit</td><td><code>void(TIndex node)</code> function to visit a node. </td></tr>
    <tr><td class="paramname">fChild</td><td><code>template &lt;TIndex c&gt; TIndex(TIndex node)</code> function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The traversal is deemed "pseudo" post-order because each visited node's children are visited in arbitrary order. The only guarantee is that a parent node is visited after its children. This is due to compile-time loops not being able to guarantee the order of execution.</dd>
<dd>
The visitor does not support sub-tree pruning, since visited nodes are always processed after their sub-tree. </dd></dl>

</div>
</div>
<a id="a8913b041f0ec99d20819d1d6a598539a" name="a8913b041f0ec99d20819d1d6a598539a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913b041f0ec99d20819d1d6a598539a">&#9670;&#160;</a></span>TraverseNAryTreePseudoPreOrder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FVisit, class FChild, class TIndex = Index, auto N = 2, auto kStackDepth = 64&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PBAT_HOST_DEVICE void pbat::common::TraverseNAryTreePseudoPreOrder </td>
          <td>(</td>
          <td class="paramtype">FVisit</td>          <td class="paramname"><span class="paramname"><em>fVisit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FChild</td>          <td class="paramname"><span class="paramname"><em>fChild</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex</td>          <td class="paramname"><span class="paramname"><em>root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-order traversal over an n-ary tree starting from root. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FVisit</td><td>Function to visit a node </td></tr>
    <tr><td class="paramname">FChild</td><td>Function to get the child of a node </td></tr>
    <tr><td class="paramname">TIndex</td><td>Type of the index </td></tr>
    <tr><td class="paramname">N</td><td>Number of children per node </td></tr>
    <tr><td class="paramname">kStackDepth</td><td>Maximum depth of the traversal's stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fVisit</td><td><code>bool(TIndex node)</code> function to visit a node. Returns true if node's sub-tree should be visited. </td></tr>
    <tr><td class="paramname">fChild</td><td><code>template &lt;TIndex c&gt; TIndex(TIndex node)</code> function to get child c of a node. Returns the child index or -1 if no child. </td></tr>
    <tr><td class="paramname">root</td><td><a class="el" href="../../d0/d7c/namespacepbat.html#ad1e4cb87f58d2ca5b10e5eb342c315e6" title="Index type.">Index</a> of the root node to start the search from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The traversal is deemed "pseudo" pre-order because each visited node's children are visited in arbitrary order. The only guarantee is that a parent node is visited before its children. This is due to compile-time loops not being able to guarantee the order of execution. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d7c/namespacepbat.html">pbat</a></li><li class="navelem"><a class="el" href="../../dd/d4e/namespacepbat_1_1common.html">common</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
