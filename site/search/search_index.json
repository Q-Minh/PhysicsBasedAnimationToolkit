{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Physics Based Animation Toolkit","text":""},{"location":"#overview","title":"Overview","text":"<p>We recommend exploring the official CMake documentation to beginner CMake users, if they wish to build this project from source.</p> <p>The Physics Based Animation Toolkit (PBAT) is a (mostly templated) cross-platform C++20 library of algorithms and data structures commonly used in computer graphics research on physically-based simulation in dimensions <code>1,2,3</code>. For most use cases, we recommend using our library via its Python interface, enabling seamless integration into Python's ecosystem of powerful scientific computing packages.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Finite Element Method (FEM) meshes and operators</li> <li>Dimensions <code>1,2,3</code></li> <li>Lagrange shape functions of order <code>1,2,3</code></li> <li>Line, triangle, quadrilateral, tetrahedron and hexahedron elements</li> <li>Hyperelastic material models</li> <li>Saint-Venant Kirchhoff</li> <li>Stable Neo-Hookean</li> <li>Polynomial quadrature rules</li> <li>Simplices in dimensions <code>1,2,3</code></li> <li>Gauss-Legendre quadrature</li> <li>Spatial query acceleration data structures</li> <li>Bounding volume hierarchy for triangles (2D+3D) and tetrahedra (3D)<ul> <li>Nearest neighbours</li> <li>Overlapping primitive pairs</li> <li>Point containment</li> </ul> </li> <li>GPU algorithms</li> <li>Vertex Block Descent (VBD)</li> <li>eXtended Position Based Dynamics (XPBD)</li> <li>Broad phase collision detection<ul> <li>Sweep and Prune</li> <li>Linear Bounding Volume Hierarchy</li> </ul> </li> <li>Fixed-size linear algebra library for kernel programming</li> <li>Seamless profiling integration via Tracy</li> </ul> <p>Currently, the <code>master</code> branch may contain breaking changes at any point in time. We recommend users to use specific git tags, i.e. via <code>git checkout v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>, where the version <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> matches the installed <code>pbatoolkit</code>'s version downloaded from PyPI (i.e. from <code>pip install pbatoolkit</code>).</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick start</li> <li>C++</li> <li>Python</li> <li>Tutorial</li> <li>Dependencies</li> <li>CUDA</li> <li>Configuration</li> <li>Build &amp; Install</li> <li>C++</li> <li>Python</li> <li>Install</li> <li>Gallery</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>We recommend downloading the Tracy profiler server to analyze execution of PBAT algorithms, available as precompiled executable. PBAT currently supports Tracy 0.10.</p>"},{"location":"#c","title":"C++","text":"<p>Take a look at the unit tests, found in the library's source (<code>.cpp</code> or <code>.cu</code>) files.</p>"},{"location":"#python","title":"Python","text":"<p>To download and install from PyPI, run in command line <pre><code>pip install pbatoolkit\n</code></pre> or, alternatively <pre><code>pip install pbatoolkit-gpu\n</code></pre> if your environment is properly setup to use our GPU algorithms.</p> <p>Verify <code>pbatoolkit</code>'s contents in a Python shell</p> <pre><code>import pbatoolkit as pbat\nhelp(pbat.fem)\nhelp(pbat.geometry)\nhelp(pbat.profiling)\nhelp(pbat.math)\nhelp(pbat.gpu)\n</code></pre> <p>A bunch of Python scripts demonstrating usage of <code>pbatoolkit</code> can be found in the examples folder, along with their associated <code>requirements.txt</code>  for easily downloading necessary dependencies via <code>pip install -r path/to/requirements.txt</code>. Their command line interface follows the pattern <pre><code>python[.exe] path/to/examples/[example].py -i path/to/input/mesh\n</code></pre> The full interface is always revealed by <code>-h</code> or <code>--help</code>, i.e.  <pre><code>python[.exe] path/to/examples/[example].py -h\n</code></pre></p> <p>The examples assume the user provides the meshes to <code>pbatoolkit</code>. Triangle (surface) meshes can easily be obtained via Thingi10K, TurboSquid or authored yourself in Blender. Tools like TetWild, fTetWild and TetGen can then convert them into tetrahedral (volume) meshes. We provide helper scripts to facilitate mesh processing and their associated <code>requirements.txt</code>.</p> <p>Example results are showcased in our Gallery.</p>"},{"location":"#tutorial","title":"Tutorial","text":"<p>Head over to our hands-on tutorials section to learn more about physics based animation in both theory and practice!</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>See <code>vcpkg.json</code> for a versioned list of our dependencies, available via vcpkg.</p> <p>Use of vcpkg is not mandatory, as long as dependencies have compatible versions and are discoverable by CMake's <code>find_package</code> mechanism.</p>"},{"location":"#cuda","title":"CUDA","text":""},{"location":"#pypi","title":"PyPI","text":"<p><code>pbatoolkit-gpu</code> (downloaded from PyPI) requires dynamically linking to an instance of the - CUDA 12 Runtime library, and your - CUDA Driver. </p> <p>Recall that the CUDA Runtime is ABI compatible up to major version.</p> <p>On 64-bit Windows, these are <code>cudart64_12.dll</code> and <code>nvcuda.dll</code>. Ensure that they are discoverable via Windows' DLL search order. We recommend adding <code>&lt;drive&gt;:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.&lt;minor&gt;\\bin</code> (i.e. the binary folder of your CUDA Toolkit installation) to the <code>PATH</code> environment variable. The driver should already be on the search path by default after installation.</p> <p>On Linux, they are <code>libcudart.so.12</code> and <code>libcuda.so.1</code>. Ensure that they are discoverable via Linux's dynamic linker/loader. If they are not already in a default search path, we recommend simply updating the library search path, i.e. <code>export LD_LIBRARY_PATH=\"path/to/driver/folder;path/to/runtime/folder;$LD_LIBRARY_PATH\"</code>.</p> <p>MacOS does not support CUDA GPUs.</p> <p>Our <code>pbatoolkit-gpu</code> prebuilt binaries include PTX, such that program load times will be delayed by JIT compilation on first use. Verify that your NVIDIA GPU supports compute capability at least 7.0. For example, only RTX 2060 up to 4090 chips are supported in the GeForce series. Runtime GPU performance may be constrained by the targeted compute capability.</p>"},{"location":"#local","title":"Local","text":"<p>Consider locally building and installing <code>pbatoolkit</code> against your native GPU for the following reasons. - Achieve optimal GPU performance for your platform. - Support older/newer GPUs and CUDA Toolkit versions.</p>"},{"location":"#configuration","title":"Configuration","text":"Option Values Default Description <code>PBAT_BUILD_PYTHON_BINDINGS</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> Python bindings. Generates the CMake target <code>PhysicsBasedAnimationToolkit_Python</code>, an extension module for Python, built by this project. <code>PBAT_BUILD_TESTS</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> unit tests. Generates the CMake target executable <code>PhysicsBasedAnimationToolkit_Tests</code>, built by this project. <code>PBAT_ENABLE_PROFILER</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>Tracy</code> instrumentation profiling in built <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code>. <code>PBAT_PROFILE_ON_DEMAND</code> <code>ON,OFF</code> <code>OFF</code> Activate Tracy's on-demand profiling when <code>PBAT_ENABLE_PROFILER</code> is <code>ON</code>. <code>PBAT_USE_INTEL_MKL</code> <code>ON,OFF</code> <code>OFF</code> Link to user-provided Intel MKL installation via CMake's <code>find_package</code>. <code>PBAT_USE_SUITESPARSE</code> <code>ON,OFF</code> <code>OFF</code> Link to user-provided SuiteSparse installation via CMake's <code>find_package</code>. <code>PBAT_BUILD_SHARED_LIBS</code> <code>ON,OFF</code> <code>OFF</code> Build project's library targets as shared/dynamic. <p>Either run CMake's configure step manually <pre><code>cmake -S &lt;path/to/PhysicsBasedAnimationToolkit&gt; -B &lt;path/to/build&gt; -D&lt;option&gt;=&lt;value&gt; ...\n</code></pre> or, alternatively (and preferably) <pre><code>cmake --preset=&lt;my-favorite-user-preset&gt;\n</code></pre></p> <p>Our project provides configuration presets that capture typical use configurations. For the best experience, install <code>vcpkg</code> and set <code>VCPKG_ROOT=path/to/vcpkg</code> as an environment variable. Then, you can select one of our available presets, for example <code>cmake --preset=default</code>. Refer to the CMake presets documentation for more information.</p>"},{"location":"#build-install","title":"Build &amp; Install","text":""},{"location":"#c_1","title":"C++","text":"<p>Build and install transparently across platforms using the cmake build CLI and cmake install CLI, respectively.</p> <p>Our CMake project exposes the following build targets | Target | Description | |---|---| | <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> | The PBA Toolkit library. | | <code>PhysicsBasedAnimationToolkit_Tests</code> | The test executable, using doctest. | | <code>PhysicsBasedAnimationToolkit_Python</code> | PBAT's Python extension module, using pybind11. |</p> <p>For example, to build tests, run <pre><code>cmake --build &lt;path/to/build/folder&gt; --target PhysicsBasedAnimationToolkit_Tests --config Release\n</code></pre></p> <p>To install PhysicsBasedAnimationToolkit locally, run <pre><code>cd path/to/PhysicsBasedAnimationToolkit\ncmake -S . -B build -D&lt;option&gt;=&lt;value&gt; ...\ncmake --install build --config Release\n</code></pre></p>"},{"location":"#python_1","title":"Python","text":"<p>For a local installation, which builds from source, our Python bindings build relies on Scikit-build-core, which relies on CMake's <code>install</code> mechanism. As such, you can configure the installation as you typically would when using the CMake CLI directly, by now passing the corresponding CMake arguments in <code>pip</code>'s <code>config-settings</code> parameter (refer to the Scikit-build-core documentation for the relevant parameters). See our pyinstall workflow for working examples of building from source on Linux, MacOS and Windows. Then, assuming that external dependencies are found via CMake's <code>find_package</code>, you can build and install our Python package <code>pbatoolkit</code> locally and get the most up to date features. </p> <p>Consider using a Python virtual environment for this step.</p> <p>As an example, assuming use of <code>vcpkg</code> for external dependency management with <code>VCPKG_ROOT=path/to/vcpkg</code> set as an environment variable, run</p> <pre><code>pip install . --config-settings=cmake.args=\"--preset=pip-cuda\" -v\n</code></pre> <p>on the command line to build <code>pbatoolkit</code> from source with GPU algorithms included. Additional environment variables (i.e. <code>CUDA_PATH</code>) and/or CMake variables (i.e. <code>CMAKE_CUDA_COMPILER</code>) may be required to be set in order for CMake to correctly discover and compile against your targeted local CUDA installation. Refer to the CMake documentation for more details.</p>"},{"location":"#gallery","title":"Gallery","text":"<p>Below, we show a few examples of what can be done in just a few lines of code using <code>pbatoolkit</code> and Python. Code can be found here.</p>"},{"location":"#real-time-hyper-elasticity-dynamics","title":"Real-time hyper elasticity dynamics","text":"<p>Our GPU implementation of the eXtended Position Based Dynamics (XPBD) algorithm simulates a ~324k element FEM elastic mesh interactively with contact.</p> <p> </p>"},{"location":"#inter-penetration-free-elastodynamic-contact","title":"Inter-penetration free elastodynamic contact","text":"<p>Combining <code>pbatoolkit</code>'s FEM+elasticity features and the <code>IPC Toolkit</code> results in guaranteed inter-penetration free contact dynamics between deformable bodies.</p> <p> </p>"},{"location":"#modal-analysis","title":"Modal analysis","text":"<p>The hyper elastic beam's representative deformation modes, i.e. its low frequency eigen vectors, are animated as time continuous signals.</p> <p> </p>"},{"location":"#gpu-broad-phase-collision-detection","title":"GPU broad phase collision detection","text":"<p>Real-time collision detection between 2 large scale meshes (~324k tetrahedra) is accelerated by highly parallel implementations of the sweep and prune algorithm, or linear bounding volume hierarchies.</p> <p> </p>"},{"location":"#harmonic-interpolation","title":"Harmonic interpolation","text":"<p>A smooth (harmonic) function is constructed on Entei, required to evaluate to <code>1</code> on its paws, and <code>0</code> at the top of its tail, using piece-wise linear (left) and quadratic (right) shape functions. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"#heat-method-for-geodesic-distance-computation","title":"Heat method for geodesic distance computation","text":"<p>Approximate geodesic distances are computed from the top center vertex of Metagross by diffusing heat from it (left), and recovering a function whose gradient matches the normalized heat's negative gradient. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"#mesh-smoothing-via-diffusion","title":"Mesh smoothing via diffusion","text":"<p>Fine details of Godzilla's skin are smoothed out by diffusing <code>x,y,z</code> coordinates in time.</p> <p> </p>"},{"location":"#profiling-statistics","title":"Profiling statistics","text":"<p>Computation details are gathered when using <code>pbatoolkit</code> and consulted in the Tracy profiling server GUI.</p> <p> </p>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#coding-style","title":"Coding style","text":"<p>A <code>.clang-format</code> description file is provided in the repository root which should be used to enforce a uniform coding style throughout the code base using the clang-format tool. Recent versions of Visual Studio Code and Visual Studio should come bundled with a <code>clang-format</code> installation. On Unix-like systems, <code>clang-format</code> can be installed using your favorite package manager.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v008-2024-04-22","title":"[v0.0.8] - 2024-04-22","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New VBD (Vertex Block Descent) implementation on the GPU. Currently does not support contacts.</li> <li>Alternative adaptive initialization strategy for VBD, differing from the strategy proposed in the VBD paper.</li> <li>Nested cage generation tool.</li> <li>Compilation of GPU code included in the CI servers within <code>pyinstall.yml</code>.</li> <li>Split PyPI package into <code>pbatoolkit</code> and <code>pbatoolkit-gpu</code> to facilitate easier usage of GPU features.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Upgraded the repository's README for improved aesthetics and better documentation on using GPU features.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul>"},{"location":"changelog/#contributors","title":"Contributors","text":"<ul> <li>@pranavAL made their first contribution in #3.</li> </ul> <p>Full Changelog: v0.0.7...v0.0.8</p>"},{"location":"changelog/#v007-2024-09-18","title":"[v0.0.7] - 2024-09-18","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Incremental Potential Contact (IPC) Python example using <code>pbatoolkit</code> as the elastodynamics engine.</li> <li>Support for optional elastic element Hessian SPD (Symmetric Positive Definite) projections.</li> <li>Parallelized Sweep and Prune GPU implementation for broad phase collision detection.</li> <li>Various C++ utilities for simpler GPU programming (e.g., device buffers, queues, stacks, lists).</li> <li>XPBD (eXtended Position Based Dynamics) implementation on the GPU using stable neo-Hookean constraints and vertex-triangle contact constraints.</li> <li>Parallelized linear BVH (Bounding Volume Hierarchy) data structure on the GPU for broad phase overlap and nearest neighbor queries.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Allow Windows system search paths to be examined for DLL resolution when importing <code>pbatoolkit</code>.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul>"},{"location":"changelog/#contributors_1","title":"Contributors","text":"<ul> <li>@pranavAL</li> </ul> <p>Full Changelog: v0.0.6...v0.0.7</p>"},{"location":"changelog/#v006-2024-07-18","title":"[v0.0.6] - 2024-07-18","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support and tests for optional integration with fast linear solvers (SuiteSparse's Cholmod and Intel MKL's Pardiso). Note: MKL Pardiso is untested and has known errors.</li> <li>Versioned NumPy and SciPy Python dependencies specified in <code>pyproject.toml</code>.</li> <li>Refactored CMake sources to facilitate shared builds, bundle transitive dependencies in Python bindings installation, and expose better CMake configure presets.</li> <li>Enabled on-demand profiling for <code>pbatoolkit</code>.</li> <li>Simplified Python FEM bindings using type erasure to minimize binary size.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.5...v0.0.6</p>"},{"location":"changelog/#v005-2024-07-12","title":"[v0.0.5] - 2024-07-12","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Tutorials on FEM using <code>pbatoolkit</code>.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Exposed more library internals to make Python scripting more flexible (e.g., quadrature points and weights on mesh, shape function gradients).</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.4...v0.0.5</p>"},{"location":"changelog/#v004-2024-07-09","title":"[v0.0.4] - 2024-07-09","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Implemented and tested optional integration with fast linear solvers (SuiteSparse's Cholmod and Intel MKL's Pardiso). Note: MKL Pardiso is untested and has known errors.</li> <li>Specified versioned NumPy and SciPy Python dependencies in <code>pyproject.toml</code>.</li> <li>Refactored CMake sources to facilitate shared builds, bundle transitive dependencies in Python bindings installation, and expose better CMake configure presets.</li> <li>Enabled on-demand profiling for <code>pbatoolkit</code>.</li> <li>Simplified Python FEM bindings using type erasure to minimize binary size.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.3...v0.0.4</p>"},{"location":"changelog/#v003-2024-06-26","title":"[v0.0.3] - 2024-06-26","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Initial release of <code>pbatoolkit</code> with the following features:</li> <li>FEM utilities (mass matrix, Laplacian, gradient, hyperelastic potential, load) for meshes in dimensions 1, 2, and 3. Supports Lagrange shape functions up to order 3 for line, triangle, quadrilateral, tetrahedral, and hexahedral elements. Note: For non-linear elements such as quads and hexes, shape function gradients and Jacobians may be inaccurate (untested).</li> <li>Efficient sparse matrix construction.</li> <li>Saint-Venant Kirchhoff and Stable Neo-Hookean material models.</li> <li>Axis-aligned Bounding Volume Hierarchies (BVH) for triangles and tetrahedra.</li> <li>Automatic profiling data generation compatible with Tracy.</li> <li>Mostly tested on tetrahedral element meshes; designed to be element-agnostic and dimension-agnostic.</li> <li>Sample code demonstrating the use of <code>pbatoolkit</code> available in the <code>examples</code> folder.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: Initial Release</p>"},{"location":"changelog/#contributors_2","title":"Contributors","text":"<ul> <li>@pranavAL - Made their first contribution in #3.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at zfergus@nyu.edu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#coding-style","title":"Coding Style","text":"<p>A <code>.clang-format</code> description file is provided in the repository root which should be used to enforce a uniform coding style throughout the code base using the clang-format tool. Recent versions of Visual Studio Code and Visual Studio should come bundled with a <code>clang-format</code> installation. On Unix-like systems, <code>clang-format</code> can be installed using your favorite package manager.</p>"},{"location":"gallery/","title":"Gallery","text":"<p>Below, we show a few examples of what can be done in just a few lines of code using <code>pbatoolkit</code> and Python. Code can be found here.</p>"},{"location":"gallery/#real-time-hyper-elasticity-dynamics","title":"Real-time Hyper Elasticity Dynamics","text":"<p>Our GPU implementation of the eXtended Position Based Dynamics (XPBD) algorithm simulates a ~324k element FEM elastic mesh interactively with contact.</p> <p> </p>"},{"location":"gallery/#inter-penetration-free-elastodynamic-contact","title":"Inter-penetration Free Elastodynamic Contact","text":"<p>Combining <code>pbatoolkit</code>\u2019s FEM+elasticity features and the <code>IPC Toolkit</code> results in guaranteed inter-penetration free contact dynamics between deformable bodies.</p> <p> </p>"},{"location":"gallery/#modal-analysis","title":"Modal Analysis","text":"<p>The hyper elastic beam's representative deformation modes, i.e., its low frequency eigen vectors, are animated as time continuous signals.</p> <p> </p>"},{"location":"gallery/#gpu-broad-phase-collision-detection","title":"GPU Broad Phase Collision Detection","text":"<p>Real-time collision detection between 2 large scale meshes (~324k tetrahedra) is accelerated by highly parallel implementations of the sweep and prune algorithm, or linear bounding volume hierarchies.</p> <p> </p>"},{"location":"gallery/#harmonic-interpolation","title":"Harmonic Interpolation","text":"<p>A smooth (harmonic) function is constructed on Entei, required to evaluate to <code>1</code> on its paws, and <code>0</code> at the top of its tail, using piece-wise linear (left) and quadratic (right) shape functions. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"gallery/#heat-method-for-geodesic-distance-computation","title":"Heat Method for Geodesic Distance Computation","text":"<p>Approximate geodesic distances are computed from the top center vertex of Metagross by diffusing heat from it (left), and recovering a function whose gradient matches the normalized heat's negative gradient. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"gallery/#mesh-smoothing-via-diffusion","title":"Mesh Smoothing via Diffusion","text":"<p>Fine details of Godzilla's skin are smoothed out by diffusing <code>x,y,z</code> coordinates in time.</p> <p> </p>"},{"location":"gallery/#profiling-statistics","title":"Profiling Statistics","text":"<p>Computation details are gathered when using <code>pbatoolkit</code> and consulted in the Tracy profiling server GUI.</p> <p> </p>"},{"location":"license/","title":"License","text":"<p>Boost Software License - Version 1.0 - August 17th, 2003</p> <p>Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the \"Software\") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:</p> <p>The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"c%2B%2B/cpp/","title":"C++","text":"<p>Here's a sample content for the <code>quick_start/cpp.md</code> file to help users get started with the C++ version of the Physics Based Animation Toolkit:</p> <pre><code># Quick Start Guide for C++\n\nThis guide will walk you through setting up the **Physics Based Animation Toolkit** for use in C++ projects. By the end of this guide, you'll be able to build and run basic simulations using the toolkit in a C++ environment.\n\n## Prerequisites\n\nBefore starting, ensure that you have the following installed:\n\n- **CMake** (version 3.15 or higher)\n- **C++17** or higher compatible compiler (GCC, Clang, MSVC, etc.)\n- **vcpkg** (for dependency management)\n- **CUDA Toolkit** (for GPU support, optional)\n- **Python 3.x** (if you plan to use the Python bindings alongside C++)\n\n## Step 1: Clone the Repository\n\nFirst, clone the Physics Based Animation Toolkit from the official GitHub repository:\n\n```bash\ngit clone https://github.com/Q-Minh/PhysicsBasedAnimationToolkit.git\ncd PhysicsBasedAnimationToolkit\n</code></pre>"},{"location":"c%2B%2B/cpp/#step-2-set-up-dependencies","title":"Step 2: Set Up Dependencies","text":"<p>We use vcpkg to manage external dependencies like Eigen and other libraries. Make sure that vcpkg is initialized and the required packages are installed.</p>"},{"location":"c%2B%2B/cpp/#install-dependencies-using-vcpkg","title":"Install Dependencies using vcpkg","text":"<p>If you haven't already set up vcpkg, follow the instructions below:</p> <pre><code># Clone vcpkg (if not installed)\ngit clone https://github.com/microsoft/vcpkg.git\ncd vcpkg\n\n# Bootstrap and integrate with your system\n./bootstrap-vcpkg.sh  # For Linux/macOS\n.\\bootstrap-vcpkg.bat  # For Windows\n\n# Integrate with your environment\n./vcpkg integrate install\n\n# Install required libraries\n./vcpkg install eigen3 jsoncpp fmt\n</code></pre> <p>The dependencies will now be available to your project when building with CMake.</p>"},{"location":"c%2B%2B/cpp/#step-3-build-the-project","title":"Step 3: Build the Project","text":"<p>You can now build the toolkit with CMake:</p> <pre><code>mkdir build\ncd build\n\n# Configure the project with CMake\ncmake .. -DCMAKE_TOOLCHAIN_FILE=../vcpkg/scripts/buildsystems/vcpkg.cmake\n\n# Build the project\ncmake --build . --config Release\n</code></pre> <p>This will build the core C++ libraries of the Physics Based Animation Toolkit.</p>"},{"location":"c%2B%2B/cpp/#step-4-run-an-example","title":"Step 4: Run an Example","text":"<p>After building, you can run one of the provided examples to verify the setup.</p>"},{"location":"c%2B%2B/cpp/#run-a-simple-simulation","title":"Run a Simple Simulation","text":"<p>The toolkit comes with example C++ code that demonstrates how to set up a simple physics simulation:</p> <pre><code>./bin/simple_simulation\n</code></pre> <p>This will execute a basic example simulation. You can modify and extend this example to suit your needs.</p>"},{"location":"c%2B%2B/cpp/#step-5-integrating-with-your-own-c-project","title":"Step 5: Integrating with Your Own C++ Project","text":"<p>To use the toolkit in your own project, link it as a library. Below is an example of how you can set this up in your CMake project:</p>"},{"location":"c%2B%2B/cpp/#cmake-configuration","title":"CMake Configuration","text":"<p>Add the following to your <code>CMakeLists.txt</code>:</p> <pre><code># Add the Physics Based Animation Toolkit to your project\nadd_subdirectory(path/to/PhysicsBasedAnimationToolkit)\n\n# Link the library\ntarget_link_libraries(your_project_name PRIVATE pbatoolkit)\n</code></pre> <p>You can now include and use the functionality provided by the Physics Based Animation Toolkit in your project.</p>"},{"location":"c%2B%2B/cpp/#step-6-gpu-support-optional","title":"Step 6: GPU Support (Optional)","text":"<p>If you want to enable GPU support, ensure you have CUDA Toolkit installed and available in your environment. GPU features can be enabled by passing the following argument to CMake during configuration:</p> <pre><code>cmake .. -DUSE_CUDA=ON\n</code></pre> <p>This will compile the GPU-specific parts of the toolkit.</p>"},{"location":"c%2B%2B/cpp/#additional-resources","title":"Additional Resources","text":"<ul> <li>Full API Documentation</li> <li>Examples and Tutorials</li> <li>Contributing Guide</li> </ul> <p>For more detailed examples and usage, please refer to the Examples section in the documentation.</p> <p>Happy coding with the Physics Based Animation Toolkit! ```</p> <p>This file provides a basic quick-start guide for using the Physics Based Animation Toolkit with C++, including installation steps, building the project, and running simple simulations. Feel free to customize the content as needed for your specific setup!</p>"},{"location":"course/fem/","title":"The Finite Element Method","text":""},{"location":"course/fem/#introduction","title":"Introduction","text":"<p>The Finite Element Method (FEM) is an approach to discretizing space-dependent continuous problems defined on geometrically \"complex\" domains. As opposed to Finite Differences (FD), which is restricted to regular grid domains, FEM relies on meshing the problem's domain (geometric discretization), describing the problem's solution as a linear combination of piece-wise (i.e., per mesh element) interpolating polynomials (functional discretization), and solving the approximated problem on the mesh. The \"Finite\" in FEM comes from limiting the approximate solution to be spanned by a \"finite-dimensional\" functional basis, i.e., the one spanned by the element-wise interpolating polynomials (the basis functions). The \"Element\" in FEM comes from the polynomials being entirely constructed/defined by the simple geometric primitives composing the mesh, called \"elements\".</p> <p></p> <p>With \\(n=|I|\\), FEM restricts \\(u(X)\\) to the class of functions \\(u(X) = \\sum_{i=1}^{n} u_i \\phi_i(X)\\), i.e., linear combinations of coefficients \\(u_i\\) and basis functions \\(\\phi_i\\) associated with nodes \\(i\\). More compactly, \\(u(X) = \\Phi^T u\\), where \\(u = \\begin{bmatrix}u_1 &amp; \\dots &amp; u_{n} \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\) and \\(\\Phi = \\begin{bmatrix} \\phi_1(X) &amp; \\dots &amp; \\phi_{n}(X) \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\). We say that the basis functions \\(\\phi_i\\) span the function space \\(\\{ \\Phi^T u \\;\\forall\\; u \\in \\mathbb{R}^{n} \\}\\), much like basis vectors \\(v_i\\) span vector spaces \\(V\\). Functions in the FEM function space, i.e., the space spanned by \\(\\phi_i\\), are uniquely represented by their vector of coefficients \\(u\\), much like vectors \\(v = v_1 \\overrightarrow{i} + v_2\\overrightarrow{j} + v_3 \\overrightarrow{k}\\) in \\(\\mathbb{R}^3\\) are uniquely represented by their coefficients \\(\\begin{bmatrix} v_1 &amp; v_2 &amp; v_3 \\end{bmatrix}\\). </p> <p></p> <p>Such a discrete functional representation allows one to accurately map continuous problems from theory onto computers by needing only to store the discrete and finite-dimensional coefficients \\(u\\) and FEM mesh \\((I,E)\\), assuming an appropriate geometric meshing of the problem domain is readily available. Furthermore, the linearity of \\(u(X)\\) w.r.t. \\(\\Phi\\) naturally translates solving FEM-discretized problems into solving matrix equations.</p>"},{"location":"course/fem/introduction/","title":"The Finite Element Method","text":""},{"location":"course/fem/introduction/#introduction","title":"Introduction","text":"<p>The Finite Element Method (FEM) is an approach to discretizing space-dependent continuous problems defined on geometrically \"complex\" domains. As opposed to Finite Differences (FD), which is restricted to regular grid domains, FEM relies on meshing the problem's domain (geometric discretization), describing the problem's solution as a linear combination of piece-wise (i.e., per mesh element) interpolating polynomials (functional discretization), and solving the approximated problem on the mesh. The \"Finite\" in FEM comes from limiting the approximate solution to be spanned by a \"finite-dimensional\" functional basis, i.e., the one spanned by the element-wise interpolating polynomials (the basis functions). The \"Element\" in FEM comes from the polynomials being entirely constructed/defined by the simple geometric primitives composing the mesh, called \"elements\".</p> <p></p> <p>With \\(n=|I|\\), FEM restricts \\(u(X)\\) to the class of functions \\(u(X) = \\sum_{i=1}^{n} u_i \\phi_i(X)\\), i.e., linear combinations of coefficients \\(u_i\\) and basis functions \\(\\phi_i\\) associated with nodes \\(i\\). More compactly, \\(u(X) = \\Phi^T u\\), where \\(u = \\begin{bmatrix}u_1 &amp; \\dots &amp; u_{n} \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\) and \\(\\Phi = \\begin{bmatrix} \\phi_1(X) &amp; \\dots &amp; \\phi_{n}(X) \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\). We say that the basis functions \\(\\phi_i\\) span the function space \\(\\{ \\Phi^T u \\;\\forall\\; u \\in \\mathbb{R}^{n} \\}\\), much like basis vectors \\(v_i\\) span vector spaces \\(V\\). Functions in the FEM function space, i.e., the space spanned by \\(\\phi_i\\), are uniquely represented by their vector of coefficients \\(u\\), much like vectors \\(v = v_1 \\overrightarrow{i} + v_2\\overrightarrow{j} + v_3 \\overrightarrow{k}\\) in \\(\\mathbb{R}^3\\) are uniquely represented by their coefficients \\(\\begin{bmatrix} v_1 &amp; v_2 &amp; v_3 \\end{bmatrix}\\). </p> <p></p> <p>Such a discrete functional representation allows one to accurately map continuous problems from theory onto computers by needing only to store the discrete and finite-dimensional coefficients \\(u\\) and FEM mesh \\((I,E)\\), assuming an appropriate geometric meshing of the problem domain is readily available. Furthermore, the linearity of \\(u(X)\\) w.r.t. \\(\\Phi\\) naturally translates solving FEM-discretized problems into solving matrix equations.</p>"},{"location":"course/fem/introduction/#prerequisites","title":"Prerequisites","text":"<ul> <li>Calculus</li> <li>Linear Algebra</li> <li>Differential equations (optional)</li> </ul>"},{"location":"workshop/","title":"Workshops","text":"<ol> <li>pbatoolkit.fem</li> <li>Heat diffusion</li> <li>Harmonic solutions</li> <li>Least squares and Poisson problems</li> <li>Lagrange elements</li> </ol>"},{"location":"workshop/W1/","title":"Workshop 1: pbatoolkit's FEM module","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <pre># Import modules of interest\nimport pbatoolkit as pbat\nimport inspect\n# Consult FEM module's API\ninspect.getmembers(pbat.fem)\nhelp(pbat.fem)\nhelp(pbat.fem.Mesh)\n</pre> # Import modules of interest import pbatoolkit as pbat import inspect # Consult FEM module's API inspect.getmembers(pbat.fem) help(pbat.fem) help(pbat.fem.Mesh) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"workshop/W1/#workshop-1-pbatoolkits-fem-module","title":"Workshop 1: pbatoolkit's FEM module\u00b6","text":"<p>This first workshop on FEM aims to help the reader:</p> <ul> <li>explore/analyze FEM quantities/operators</li> <li>familiarize themself with our Physics Based Animation Toolkit's Python interface</li> </ul> <p>Start by installing the required dependencies by running <code>pip install -r requirements.txt</code> on the command line. FEM relies on having meshed geometries at hand, hence we recommend finding clean surface mesh geometry and then using our mesh processing scripts to tetrahedralize them, if you don't already have access to meshes. You can download surface meshes on Thingi10K, TurboSquid or other.</p> <p>If you are interested in profiling calls to FEM operations, also download the Tracy profiling server, run <code>tracy.exe</code> and connect to this process.</p>"},{"location":"workshop/W1/#loading-input-mesh-geometry","title":"Loading input mesh geometry\u00b6","text":"<p>Use meshio to load meshes from disk to memory, and render them using polyscope.</p>"},{"location":"workshop/W1/#constructing-fem-meshes","title":"Constructing FEM meshes\u00b6","text":"<p>From the input mesh geometry, construct an FEM mesh (i.e. <code>pbatoolkit.fem.Mesh</code>) using <code>pbatoolkit</code>. Start by exploring the API of the FEM module of <code>pbatoolkit</code>. Then, try constructing meshes of different shape function orders on either of line, triangle, and/or tetrahedral meshes. You can do the same for regular geometry (rectangles and boxes) if you want.</p> <p><code>pbatoolkit</code> expects input matrix data in column major storage (i.e. <code>order='F'</code> in numpy) and uses double precision floating point numbers as scalars, and 64-bit signed integers as indices. Vertex positions are generally packed in matrix columns, and similarly for cell indices. This format is generally compatible with other packages' APIs, using a no-copy transpose operation (i.e. a row-major <code>order='C'</code> matrix with vertex positions in rows has the same memory layout as a column-major <code>order='F'</code> matrix with vertex positions in columns).</p> <p>Use Python's <code>help</code> command on <code>pbatoolkit</code>'s mesh instance, and check that you can access its nodes' positions, its elements' nodal indices, its dimensionality, element type, etc.</p> <p>Note that the FEM mesh and the geometric mesh do NOT share the same element indices. Both the FEM and geometric mesh have the same number of elements, and they are ordered in exactly the same way, but the geometric mesh's array of vertex positions does not necessarily correspond to the FEM mesh's array of node positions.</p> <p>Keep an eye on how the number of FEM nodes changes when the mesh's shape function order changes, and the computational cost of constructing higher order meshes. Visualize the FEM mesh's nodes on top of the geometric mesh using <code>polyscope</code>.</p>"},{"location":"workshop/W1/#mass-matrix","title":"Mass matrix\u00b6","text":"<ol> <li>Construct the mass matrix using <code>pbatoolkit</code>'s built-in <code>MassMatrix</code> class, and then using only the shape function and quadrature matrices, and compare the resulting mass matrices. Call <code>to_matrix</code> to get a <code>scipy</code> sparse matrix from <code>pbatoolkit</code>'s mass matrix instance.</li> <li>Analyze its properties. Is it square, symmetric, positive definite? What is its sparsity?</li> <li>What happens if you use the correct quadrature order, a lower quadrature order, and a higher quadrature order?</li> <li>How computationally costly is mass matrix construction in both cases?</li> </ol>"},{"location":"workshop/W1/#load-vector","title":"Load vector\u00b6","text":"<ol> <li>Construct a piecewise polynomial load vector using <code>pbatoolkit</code>'s shape function and quadrature matrices (use <code>pbat.fem.shape_function_matrix</code> and <code>pbat.fem.inner_product_weights</code>). Refer to examples for help. Alternatively, the load vector can be defined at nodes, in which case you only need the mass matrix (<code>pbat.fem.MassMatrix</code>). You can use some common forcing function, like gravity, i.e. $f_e(X) = [0, 0, -9.81]$. Compare the resulting discrete load vectors.</li> <li>Try constructing different load vectors using different quadrature orders and analyze the results.</li> <li>How computationally costly is its construction in all cases?</li> </ol>"},{"location":"workshop/W1/#laplacian-matrix","title":"Laplacian matrix\u00b6","text":"<ol> <li>Construct the Laplacian matrix using <code>pbatoolkit</code>'s built-in <code>pbat.fem.Laplacian</code> class, and then using only the gradient (<code>pbat.fem.Gradient</code>) and quadrature matrices (<code>pbat.fem.inner_product_weights</code>), and compare the resulting Laplacians.</li> <li>Analyze its properties, similar to the mass matrix case.</li> <li>Try varying the quadrature orders and evaluate the consequences.</li> <li>What is the computational cost of its different construction approaches?</li> </ol>"},{"location":"workshop/W1/#higher-order-fem","title":"Higher order FEM\u00b6","text":"<p>When using higher-order FEM, it is often useful to visualize our discretized functions on refined versions of our input geometric mesh. This is due to the fact that renderers that support scalar field visualization use linear interpolation to fill the colors between mesh vertices, so we need to use \"visual\" meshes of higher resolution than our \"geometric\" mesh to see any difference.</p> <p>You can refine meshes using our mesh processing scripts. Then, in code, use <code>pbat.geometry.bvh</code> to compute a spatial query acceleration data structure, our bounding volume implementation (BVH), on the \"geometric\" mesh. Vertices of the \"visual\" mesh should be mapped to the \"computational\" mesh (i.e. the FEM mesh) by</p> <ol> <li>Querying in which element of the \"geometric\" mesh they reside. This query can be greatly accelerated using the BVH.</li> <li>Use <code>pbat.fem.reference_positions</code> to compute the reference element positions of the visual mesh nodes.</li> <li>Use <code>pbat.fem.shape_functions_at</code> to evaluate the shape functions at the visual mesh nodes, using their corresponding reference positions.</li> <li>Evaluate the FEM function by coefficient-wise multiplication between nodal coefficients and associate shape functions evaluated at visual mesh nodes, and compute their sum separately (for each visual mesh node).</li> </ol> <p>Refer to this higher order example for help.</p>"},{"location":"workshop/W1/#solutions","title":"Solutions\u00b6","text":"<p>Scripts in the examples folder show different ways to construct relevant FEM quantities using <code>pbatoolkit</code> for different mesh types, different shape function orders, and different construction approaches.</p>"},{"location":"workshop/W2/","title":"Workshop 2: Heat equation","text":"<p>The final result should be a matrix system of equations in the form $\\alpha L u = M \\frac{\\partial u}{\\partial t}$.</p> <p>The final result should be $(M - \\Delta t \\alpha  L) u^{t+1} = M u^t$.</p> In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <p>One way is to impose Dirichlet boundary conditions, i.e. constrain the solution to satisfy $u(X_D,t) = d(X_D,t)$ for some known function $d(X,t)$, where $X_D$ are positions that are part of the heat source.</p> <ol> <li>On our discrete heat equation, pick vertices that are part of the heat source, and set their corresponding entries in the solution coefficient vector $u$ to your preferred heat source's temperature. You can use <code>pbatoolkit.geometry.aabb</code> to pick all vertices inside the prescribed axis-aligned box, to facilitate vertex selection.</li> <li>Impose these Dirichlet boundary conditions as described in the documentation's section on boundary conditions. Once the known degrees of freedom are collected (in a list or array), you can use numpy.setdiff1d to get the unknowns. Using the index lists, you can extract submatrices of the lead sparse matrix via slicing with scipy.</li> </ol> In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied!"},{"location":"workshop/W2/#workshop-2-heat-equation","title":"Workshop 2: Heat equation\u00b6","text":"<p>We now turn to solving a classical (linear) partial differential equation (PDE), the heat equation</p> <p>$$ \\alpha \\Delta u(X,t) = \\frac{\\partial u(X,t)}{\\partial t} , $$</p> <p>using FEM. The solution's time integration will be discretized with a first order backward differentiation approach, otherwise known as Backward Euler.</p>"},{"location":"workshop/W2/#fem-discretization","title":"FEM discretization\u00b6","text":"<p>Start by discretizing (by hand) the heat equation in the space variables only, using FEM. Treat the time derivative of heat as a forcing function for now.</p>"},{"location":"workshop/W2/#time-discretization","title":"Time discretization\u00b6","text":"<p>Discretize the heat's time derivative, which we previously considered to be a forcing function, using backward finite differences and a time step $\\Delta t$. Collect the unknowns on the left-hand side of the discretized matrix equation.</p>"},{"location":"workshop/W2/#solve-heat-equation","title":"Solve heat equation\u00b6","text":"<ol> <li>Use <code>pbatoolkit</code>'s <code>pbatoolkit.math.linalg.ldlt</code> function to factorize the discretized heat equation's lead matrix for a given mesh of your choosing.</li> <li>Our discrete heat equation is now an initial value problem IVP, such that the initial condition $u(t=0) = u^0$ must be given. Notice that $u^t$ must be discretized at FEM nodes, since it is to be projected (in the Galerkin sense) via the mass matrix $M$. Thus, pick a subset of FEM nodes, and initialize their heat values to $1$ (or something else). Set the initial heat values of other nodes to $0$ (or something else). You can use the function <code>pbatoolkit.geometry.aabb</code> to aid in selecting FEM nodes in box regions, or select them manually in <code>polyscope</code>, Blender, MeshLab or other. Otherwise, pick at random.</li> <li>Solve the IVP for a certain number of time steps $T$ and visualize each time step's heat distribution over the mesh using <code>polyscope</code>.</li> <li>What happens when you change the diffusivity constant $\\alpha$, the time step size $\\Delta t$?</li> </ol>"},{"location":"workshop/W2/#linear-solver","title":"Linear solver\u00b6","text":"<ol> <li>Choose a different linear solver for the IVP. Try, for instance, <code>scipy</code>'s sparse LU factorization. Analyze the computational cost of different approaches.</li> <li>If the results are different, consider why.</li> <li>What happens if a dense linear solver is used, rather than a sparse one?</li> </ol>"},{"location":"workshop/W2/#heat-sources","title":"Heat sources\u00b6","text":"<p>How should you model a heat source? These are regions in your domain (i.e. the FEM mesh) which emit constant heat.</p>"},{"location":"workshop/W2/#smoothing","title":"Smoothing\u00b6","text":"<p>The physical interpretation of \"heat\" that we associated with the solution vector $u$ was not necessary. Can you apply the heat/diffusion equation to some other functions?</p> <ol> <li>Solve the heat equation on each spatial position of the FEM mesh's node positions. The initial conditions for this problem should be the initial FEM mesh's node positions. You can treat this as 3 separate IVPs for each spatial dimension. Visualize the mesh using the new positions at each time step.</li> <li>Can the discrete heat equation's lead matrix be re-used?</li> <li>Change parameters $\\alpha, \\Delta t$ and visualize results.</li> <li>Constrain some nodal positions to be fixed. What happens?</li> </ol>"},{"location":"workshop/W3/","title":"Workshop 3: Harmonic solutions","text":"<p>For the Dirichlet energy, the final result should be $\\min_u -\\frac{1}{2} u^T L u$, where $L$ is the symmetric part of the Laplacian energy. For the Laplace equation, we simply get $Lu = 0$.</p> In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! <p>A better smoothness energy is described in Natural Boundary Conditions for Smoothing in Geometry Processing and A Smoothness Energy without Boundary Distortion for Curved Surfaces, among other potential approaches.</p>"},{"location":"workshop/W3/#workshop-3-harmonic-solutions","title":"Workshop 3: Harmonic solutions\u00b6","text":"<p>Workshop 2 showed that the heat/diffusion equation could be used on general functions (i.e. heat or positions) to smooth them. As the solution evolved in time, it would get smoother and smoother. In fact, one might wonder what happens at the \"end\" of such a diffusion, i.e. the steady state? In this setting, the time derivative of the function would vanish, i.e. $\\frac{\\partial u}{\\partial t} = 0$, since $u$ does not change in the steady state. This leads to the harmonic (or Laplace) equation $\\Delta u = 0$. Functions which satisfy this equation are said to be harmonic. In general, harmonic functions are quite smooth, and we can thus often \"enforce\" smoothness on desired solutions by making them harmonic. This smoothness is even more obvious when we consider how harmonic functions are minimizers of the Dirichlet (or smoothness) energy</p> <p>$$ \\Delta u(X) = 0 \\longrightarrow u = \\min_u \\frac{1}{2} \\int_{\\Omega} || \\nabla u(X) ||_2^2 \\partial \\Omega . $$</p>"},{"location":"workshop/W3/#fem-discretization","title":"FEM discretization\u00b6","text":"<ol> <li>Discretize the Dirichlet energy using FEM.</li> <li>Discretize the Laplace equation using FEM.</li> </ol>"},{"location":"workshop/W3/#solving-the-laplace-equation","title":"Solving the Laplace equation\u00b6","text":"<p>In workshop 1, we learned that the Laplace equation is in fact rank deficient (by 1). We will thus need to impose some Dirichlet boundary conditions on the solution to obtain a unique harmonic function.</p> <ol> <li>Show that the Laplacian is rank deficient (on paper).</li> <li>Confirm that it is numerically rank deficient (even if workshop 1 already asks this).</li> </ol>"},{"location":"workshop/W3/#interpolation-problems","title":"Interpolation problems\u00b6","text":"<p>The \"smoothness\" minimization framework for thinking about the Laplace equation naturally allows us to formulate interpolation as finding the smoothest scalar function which interpolates the Dirichlet boundary conditions. In other words,</p> <p>$$ \\min_u -u^T L u \\quad\\text{s.t.}\\quad u_D = d_D  $$</p> <p>for some set of Dirichlet nodes $D$ and their corresponding imposed values $d_D$. Knowing that $-L$ is positive semi-definite with a single missing rank, we need at least $1$ boundary condition, and we can solve this minimization by setting the gradient to $0$, yielding the reduced linear system</p> <p>$$ L_{uu} u_u = L_{uD} d_D , $$</p> <p>where the subscripts $u,D$ are to be taken as indices to unknown degrees of freedom, and indices to known degrees of freedom (i.e. Dirichlet boundary conditions), respectively.</p> <ol> <li>Constrain 2 parts of the mesh to have values $0$ in the first part, and $1$ in the second part. Solve this Dirichlet constrained minimization. We are essentially interpolating between $0$ and $1$ on some complex and curved geometry (the mesh). Much cooler than interpolation on a line segment or in a box!</li> <li>Consider the vector-valued function of displacements from FEM nodal positions as a minimizer to the Dirichlet energy. In other words, we wish to find some smooth displacement field that takes FEM node positions to some smoother positional configuration. Constrain some region of the FEM mesh to be fixed. Constrain another region of the FEM mesh to \"move\" someplace else, by setting the corresponding Dirichlet conditions in $X,Y,Z$ dimensions to have a non-trivial displacement $[d_X, d_Y, d_Z]$. Solve for the $3$ resulting interpolants and visualize the result. You have essentially implemented harmonic deformation, a popular framework for shape deformation!</li> </ol>"},{"location":"workshop/W3/#k-harmonic-interpolation","title":"k-Harmonic interpolation\u00b6","text":"<p>It should be natural to wonder if smoother functions can be obtained in this same framework. In other words, why not minimize change in first derivatives and second derivatives and higher order derivatives? This leads to the k-harmonic equation</p> <p>$$ \\Delta^k u(X) = 0 , $$</p> <p>where $\\Delta^k$ applies the Laplacian $k$ times. Unfortunately, on first impression, it might seem like this would require our discretized $u(X)$ to be $2k$ times differentiable (ignoring that constant functions are differentiable). In other words, our basis functions $\\phi_i(X)$ should be $2k$ times differentiable. However, this problem can be solved using only linear basis functions by thinking recursively. We can create auxiliary variables $u^{k-1}(X) = \\Delta^{k-1} u(X)$ and start by solving for $\\Delta u^{k-1}(X) = 0$. Then, recursively solve $\\Delta u^{k-i}(X) = u^{k-i+1}(X)$. Unrolling this loop yields</p> <p>$$ \\Delta (\\dots (\\Delta u(X))) = 0 , $$</p> <p>where $u(X) = u^{1}(X)$. Discretizing each intermediate (sub)problem using FEM, we get that</p> <p>$$ L u^{k-i} = M u^{k-i+1} , $$</p> <p>as we have shown here, where $u^{k-i+1}(X)$ is considered as a forcing function in the $i^\\text{th}$ subproblem. Because we know that FEM functions are interpolating, this must mean that the coefficients in $u^{k-i+1}$ are the actual values of the Laplacian of $u^{k-i}(X)$ at the FEM nodes, and we can obtain such Laplacians via</p> <p>$$ M^{-1} L u^{k-i} = u^{k-i+1} . $$</p> <p>Thinking recursively again, we realize that $u^{k-i+1}$ was also obtained by applying the matrix $M^{-1} L$ to $u^{k-i+2}$. At the end of this recursion, we get $L u^k = 0$ without any mass matrix term. Unrolling this whole recursion, we end up with the system</p> <p>$$ \\left[ L M^{-1} \\dots L M^{-1} L \\dots M^{-1} L \\right] u = 0 , $$</p> <p>subject to Dirichlet boundary conditions for a well-defined solution to exist. This system is valid for linear shape functions, even if its solution is of higher order. A more in depth mixed finite elements derivation of this technique, including various other types of boundary conditions is described in Mixed Finite Elements for Variational Surface Modeling.</p> <ol> <li>What are the properties of the lead matrix $\\left[ L M^{-1} \\dots L M^{-1} L \\dots M^{-1} L \\right]$ for $k=1,2,3$?</li> <li>Solve the same interpolation problems as in the previous cell, but now minimizing a k-harmonic energy for $k=1,2,3$. What happens as $k$ increases?</li> <li>What \"energy\" are we minimizing by solving the $k$-harmonic equation? Try to derive this on paper.</li> </ol>"},{"location":"workshop/W4/","title":"Workshop 4: Poisson and least-squares problems","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied!"},{"location":"workshop/W4/#workshop-4-poisson-and-least-squares-problems","title":"Workshop 4: Poisson and least-squares problems\u00b6","text":"<p>We now turn our attention to least-squares problems on the gradient of the solution</p> <p>$$ \\min_u \\frac{1}{2} \\int_{\\Omega } || \\nabla u(X) - F(X) ||_2^2 \\partial \\Omega , $$</p> <p>and on the solution itself (function approximation by error minimization)</p> <p>$$ \\min_u \\frac{1}{2} \\int_{\\Omega } \\left[ u(X) - f(X) \\right]^2 \\partial \\Omega . $$</p>"},{"location":"workshop/W4/#poisson-equation","title":"Poisson equation\u00b6","text":"<ol> <li>Show that global minimizers to the gradient error minimization are solutions to the Poisson equation</li> </ol> <p>$$ \\Delta u(X) = \\nabla \\cdot F(X), \\quad X \\in \\Omega . $$</p> <ol> <li>Discretize the Poisson equation using FEM (on paper). If $F(X)$ is discretized at element quadrature points into $F \\in \\mathbb{R}^{d|E|q \\times 1}$, you should get $L u = -D [I_{d \\times d} \\otimes Q] F$. If $F(X)$ is discretized at the nodes into $F \\in \\mathbb{R}^{dn \\times 1}$, you should get $L u = -D [I_{d \\times d} \\otimes Q N] F$.</li> </ol>"},{"location":"workshop/W4/#heat-method-for-geodesic-distance-computation","title":"Heat method for geodesic distance computation\u00b6","text":"<p>One (of many) situations in which the Poisson equation shows up is in the Heat method for geodesic distance computation. In a nutshell, geodesic distances are lengths of the shortest paths between 2 points, where all possible paths must remain inside the domain $\\Omega$. In Euclidean space, the shortest path between 2 points is the straight line connecting the points. But let's say you live in a world that is shaped like a donut? Then traveling from one side of the donut to the other, while staying inside the donut, will require you to walk in a circular (curved) trajectory.</p> <p>There exist algorithms which compute exact geodesic distances in meshed domains. See The Discrete Geodesic Problem, Fast Exact and Approximate Geodesic Paths on Meshes, for example, for the particular case of surface meshes. In contrast, the heat method aims to compute approximate geodesic distances, but the results can be refined (see On Variational and PDE-based Distance Function Approximations, for example).</p> <p>The general idea behind the heat method is to consider how heat should flow from a source to any other point in the domain $\\Omega$ in the most optimal (shortest path) way. Consider a room (i.e. the domain $\\Omega$) that is split in half by a wall, but the wall has a hole in its center. Suppose that heat cannot pierce through the walls. Suppose that a heat source is fixed and activated on one side of the wall, and you are on the other side of the wall at the same level. How would heat flow to the other side of the room and reach you? Intuitively, it would go exactly along the wall on the same side as the source, and as soon as it encounters the hole in the wall, it will bend, go through the hole, and bend once more in the same direction, and go along the other side of the wall until it reaches you. If we normalize this heat flow, so that the heat can only ever flow with the same velocity of $1$ meter per second, then we should have essentially reconstructed the gradient of the geodesic distance function, since distance functions must have unit gradient. This leads to the following algorithm, which you will implement (on a mesh of your choosing):</p> <ol> <li><p>Compute a heat flow by first solving the heat equation subject to the initial conditions $u(X,t=0) = 1$ if $X$ is part of the heat source, and 0 otherwise. Solve for this heat for a certain period of time, obtaining $u(X,t)$, the heat at time $t$ (1 time step should be enough). The suggested time step to use (refer to the paper) is a multiple $k$ of the mesh's squared average edge length. Then, compute the negative gradient of the heat, obtaining the heat's flow $-\\nabla u(X,t)$.</p> </li> <li><p>Normalize the flow, obtaining $F(X) = \\frac{-\\nabla u(X,t)}{|\\nabla u(X,t)|}$.</p> </li> <li><p>Solve for a function $\\phi(X)$ whose gradient matches the normalized heat flow, i.e. solve the problem</p> <p>$$  \\min_\\phi \\int_{\\Omega} || \\nabla \\phi(X) - F(X) ||^2 \\partial \\Omega .  $$</p> <p>This is a Poisson problem on which FEM can be applied (as shown in the previous section). However, recall that the Laplacian $L$ is rank-deficient (but symmetric negative definite). One can use <code>pbatoolkit.math.linalg.ldlt</code> to factorize such a matrix and solve the discrete Poisson equation. However, because the laplacian $\\Delta u(X)$ is scale and translation invariant, i.e. $\\Delta u(X) = 0$, $\\Delta \\alpha u(X) = 0$, $\\Delta (u(X) + K) = 0$, the Poisson solution may be shifted and/or reflected. Knowing that the distance from the source to the source should be $0$, we can simply shift the whole Poisson solution up by the computed distance at the source (after having handled reflection). If there are many sources, use the average of the computed distances at the sources as the shift.</p> </li> <li><p>Visualize the heat distribution and the corresponding geodesic distance function on the mesh using <code>polyscope</code>. You can also visualize isolines of the distance function using <code>libigl</code>.</p> </li> <li><p>What happens if you add regularization to the Laplacian $L$ in the Poisson solve?</p> </li> </ol>"},{"location":"workshop/W4/#least-squares-error-minimization","title":"Least-squares error minimization\u00b6","text":"<p>An intuitive approach to function approximation is to directly minimize the error between our discrete FEM function $u(X)$ and some target known function $f(X)$ that we wish to approximate. This is mathematically formulated as</p> <p>$$ \\min_u \\frac{1}{2} \\int_{\\Omega} \\left[ u(X) - f(X) \\right]^2 \\partial \\Omega . $$</p> <p>If we discretize $u(X)$ using FEM into the coefficient vector $u$ and basis functions $\\phi_i(X)$, and we sample the function $f(X)$ at element quadrature points, the resulting minimization becomes</p> <p>$$ \\min_u \\frac{1}{2} (N u - f)^T Q (N u - f) . $$</p> <p>We can immediately solve this minimization by setting the gradient with respect to our unknown coefficients $u$ to zero. This leads to the linear system of equations</p> <p>$$ N^T Q N u = N^T Q f \\leftrightarrow M u = N^T Q f , $$</p> <p>where $M$ is the mass matrix, and $N^T Q$ is a Galerkin projection operator on the forcing function $f$. This hints at the fact that the forcing function $f$ may also be discretized at the FEM nodes instead, yielding</p> <p>$$ Mu = Mf \\longrightarrow u = f $$</p> <p>which immediately reveals the solution vector $u$ without requiring a linear solver. In this case, we simply need to know how to evaluate the function $f(X)$ at the nodes.</p>"},{"location":"workshop/W4/#signed-distance-function-approximation","title":"Signed distance function approximation\u00b6","text":"<p>Although signed distance functions (SDFs) in general are of great interest in many fields, we restrict our attention to approximate signed distance functions, a popular implicit representation of geometry for efficient contact detection and handling in animation. See An hp-adaptive discretization algorithm for signed distance field generation, Local Optimization for Robust Signed Distance Field Collision, Signed distance fields for polygon soup meshes, for example.</p> <p>We will use the framework of FEM function approximation presented in the previous section to approximate SDFs.</p> <ol> <li>Construct an FEM (volumetric) mesh of the domain in which you want the SDF to be supported. Use an order 1 mesh in this step. If you want to use a grid-like domain, i.e. using hexahedral FEM elements, make sure that the input hexahedral mesh geometry is given with element vertices ordered according to Lagrange coordinates. This means that the 8 hexahedron vertices should be ordered as <code>[left-front-bottom, right-front-bottom, left-back-bottom, right-back-bottom, left-front-top, right-front-top, left-back-top, right-back-top]</code>.</li> <li>Load some surface mesh of your choice. We are going to approximate the signed distance function to that surface.</li> <li>Evaluate the mesh signed distance function to the surface mesh at FEM nodes using <code>libigl</code>. Use the winding number variant for robust and accurate distance computation (if your input surface is of poor quality).</li> <li>Refine the volumetric input mesh of the domain and evaluate the FEM discretized approximate SDF at the refined volumetric mesh's vertices. Visualize the SDF on the refined mesh using <code>polyscope</code>.</li> <li>Recompute the same SDF FEM approximation pipeline, but now using quadratic shape functions, and then cubic shape functions. Visualize the results on the refined mesh again. Is there a difference?</li> <li>Evaluate the error for all 3 approximations.</li> </ol>"},{"location":"workshop/W4/#other-applications","title":"Other applications\u00b6","text":"<p>Poisson solutions are used in many other works. For example, we can reconstruct an implicit surface from a point cloud using Poisson Surface Reconstruction and its numerous derivative works, or enforce incompressibility in fluid simulation for advection-projection schemes (see Fluid Simulation for Computer Animation), for example.</p>"},{"location":"workshop/W5/","title":"Workshop 5: Lagrange elements","text":"In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied! In\u00a0[\u00a0]: Copied!"},{"location":"workshop/W5/#workshop-5-lagrange-elements","title":"Workshop 5: Lagrange elements\u00b6","text":"<p>We now turn to deriving shape functions for different elements, the fundamental building block for FEM discretization. In particular, we focus on the Lagrange elements. Instead of deriving shape functions by hand, we will systematically solve for these shape functions using the interpolation problem described here in the subsection on shape functions. To do so, we will use a symbolic calculator, sympy.</p>"},{"location":"workshop/W5/#lagrange-nodes","title":"Lagrange nodes\u00b6","text":"<ol> <li>Compute the Lagrange nodal positions for the reference line, triangle, quadrilateral, tetrahedron and hexahedron. You can use sympy's rational numbers to store exact coordinates.</li> <li>Visualize the reference elements and their nodes.</li> </ol>"},{"location":"workshop/W5/#lagrange-shape-functions","title":"Lagrange shape functions\u00b6","text":"<ol> <li>Setup the shape function interpolation problem, i.e. the polynomial matrix inversion problem, using symbolic positions. Use sympy's <code>Symbol</code> and similar <code>MatrixSymbol</code> classes to help out. Refer to the Introduction to SymPy and the Matrices module.</li> <li>Solve the interpolation problem (i.e. matrix inversion) using a symbolic matrix inversion.</li> <li>Compute the resulting shape functions and (pretty) print them.</li> <li>Validate that the shape functions are indeed interpolating at their associated node, and vanish at other nodes. In other words, check that they satisfy the Kronecker delta property.</li> <li>Differentiate the shape functions to obtain their gradients. Print them.</li> <li>Apply other differential operators (higher order derivatives, integrals, etc.) to the shape functions, if you are interested.</li> </ol>"},{"location":"workshop/W5/#code-generation","title":"Code generation\u00b6","text":"<ol> <li>Generate code for shape function computation using SymPy's code printers.</li> <li>Generate code for shape function gradients.</li> </ol>"},{"location":"workshop/W5/#solutions","title":"Solutions\u00b6","text":"<p>Our implementation of shape functions and their gradients is code-generated. See our Lagrange element script and the C++ code printer it uses.</p>"}]}