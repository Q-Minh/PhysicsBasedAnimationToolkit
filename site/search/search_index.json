{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Physics Based Animation Toolkit","text":""},{"location":"#overview","title":"Overview","text":"<p>We recommend exploring the official CMake documentation to beginner CMake users, if they wish to build this project from source.</p> <p>The Physics Based Animation Toolkit (PBAT) is a (mostly templated) cross-platform C++20 library of algorithms and data structures commonly used in computer graphics research on physically-based simulation in dimensions <code>1,2,3</code>. For most use cases, we recommend using our library via its Python interface, enabling seamless integration into Python's ecosystem of powerful scientific computing packages.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Finite Element Method (FEM) meshes and operators</li> <li>Dimensions <code>1,2,3</code></li> <li>Lagrange shape functions of order <code>1,2,3</code></li> <li>Line, triangle, quadrilateral, tetrahedron and hexahedron elements</li> <li>Hyperelastic material models</li> <li>Saint-Venant Kirchhoff</li> <li>Stable Neo-Hookean</li> <li>Polynomial quadrature rules</li> <li>Simplices in dimensions <code>1,2,3</code></li> <li>Gauss-Legendre quadrature</li> <li>Spatial query acceleration data structures</li> <li>Bounding volume hierarchy for triangles (2D+3D) and tetrahedra (3D)<ul> <li>Nearest neighbours</li> <li>Overlapping primitive pairs</li> <li>Point containment</li> </ul> </li> <li>GPU algorithms</li> <li>Vertex Block Descent (VBD)</li> <li>eXtended Position Based Dynamics (XPBD)</li> <li>Broad phase collision detection<ul> <li>Sweep and Prune</li> <li>Linear Bounding Volume Hierarchy</li> </ul> </li> <li>Fixed-size linear algebra library for kernel programming</li> <li>Seamless profiling integration via Tracy</li> </ul> <p>Currently, the <code>master</code> branch may contain breaking changes at any point in time. We recommend users to use specific git tags, i.e. via <code>git checkout v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>, where the version <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> matches the installed <code>pbatoolkit</code>'s version downloaded from PyPI (i.e. from <code>pip install pbatoolkit</code>).</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick start</li> <li>C++</li> <li>Python</li> <li>Tutorial</li> <li>Dependencies</li> <li>CUDA</li> <li>Configuration</li> <li>Build &amp; Install</li> <li>C++</li> <li>Python</li> <li>Install</li> <li>Gallery</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>We recommend downloading the Tracy profiler server to analyze execution of PBAT algorithms, available as precompiled executable. PBAT currently supports Tracy 0.10.</p>"},{"location":"#c","title":"C++","text":"<p>Take a look at the unit tests, found in the library's source (<code>.cpp</code> or <code>.cu</code>) files.</p>"},{"location":"#python","title":"Python","text":"<p>To download and install from PyPI, run in command line <pre><code>pip install pbatoolkit\n</code></pre> or, alternatively <pre><code>pip install pbatoolkit-gpu\n</code></pre> if your environment is properly setup to use our GPU algorithms.</p> <p>Verify <code>pbatoolkit</code>'s contents in a Python shell</p> <pre><code>import pbatoolkit as pbat\nhelp(pbat.fem)\nhelp(pbat.geometry)\nhelp(pbat.profiling)\nhelp(pbat.math)\nhelp(pbat.gpu)\n</code></pre> <p>A bunch of Python scripts demonstrating usage of <code>pbatoolkit</code> can be found in the examples folder, along with their associated <code>requirements.txt</code>  for easily downloading necessary dependencies via <code>pip install -r path/to/requirements.txt</code>. Their command line interface follows the pattern <pre><code>python[.exe] path/to/examples/[example].py -i path/to/input/mesh\n</code></pre> The full interface is always revealed by <code>-h</code> or <code>--help</code>, i.e.  <pre><code>python[.exe] path/to/examples/[example].py -h\n</code></pre></p> <p>The examples assume the user provides the meshes to <code>pbatoolkit</code>. Triangle (surface) meshes can easily be obtained via Thingi10K, TurboSquid or authored yourself in Blender. Tools like TetWild, fTetWild and TetGen can then convert them into tetrahedral (volume) meshes. We provide helper scripts to facilitate mesh processing and their associated <code>requirements.txt</code>.</p> <p>Example results are showcased in our Gallery.</p>"},{"location":"#tutorial","title":"Tutorial","text":"<p>Head over to our hands-on tutorials section to learn more about physics based animation in both theory and practice!</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>See <code>vcpkg.json</code> for a versioned list of our dependencies, available via vcpkg.</p> <p>Use of vcpkg is not mandatory, as long as dependencies have compatible versions and are discoverable by CMake's <code>find_package</code> mechanism.</p>"},{"location":"#cuda","title":"CUDA","text":""},{"location":"#pypi","title":"PyPI","text":"<p><code>pbatoolkit-gpu</code> (downloaded from PyPI) requires dynamically linking to an instance of the - CUDA 12 Runtime library, and your - CUDA Driver. </p> <p>Recall that the CUDA Runtime is ABI compatible up to major version.</p> <p>On 64-bit Windows, these are <code>cudart64_12.dll</code> and <code>nvcuda.dll</code>. Ensure that they are discoverable via Windows' DLL search order. We recommend adding <code>&lt;drive&gt;:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.&lt;minor&gt;\\bin</code> (i.e. the binary folder of your CUDA Toolkit installation) to the <code>PATH</code> environment variable. The driver should already be on the search path by default after installation.</p> <p>On Linux, they are <code>libcudart.so.12</code> and <code>libcuda.so.1</code>. Ensure that they are discoverable via Linux's dynamic linker/loader. If they are not already in a default search path, we recommend simply updating the library search path, i.e. <code>export LD_LIBRARY_PATH=\"path/to/driver/folder;path/to/runtime/folder;$LD_LIBRARY_PATH\"</code>.</p> <p>MacOS does not support CUDA GPUs.</p> <p>Our <code>pbatoolkit-gpu</code> prebuilt binaries include PTX, such that program load times will be delayed by JIT compilation on first use. Verify that your NVIDIA GPU supports compute capability at least 7.0. For example, only RTX 2060 up to 4090 chips are supported in the GeForce series. Runtime GPU performance may be constrained by the targeted compute capability.</p>"},{"location":"#local","title":"Local","text":"<p>Consider locally building and installing <code>pbatoolkit</code> against your native GPU for the following reasons. - Achieve optimal GPU performance for your platform. - Support older/newer GPUs and CUDA Toolkit versions.</p>"},{"location":"#configuration","title":"Configuration","text":"Option Values Default Description <code>PBAT_BUILD_PYTHON_BINDINGS</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> Python bindings. Generates the CMake target <code>PhysicsBasedAnimationToolkit_Python</code>, an extension module for Python, built by this project. <code>PBAT_BUILD_TESTS</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> unit tests. Generates the CMake target executable <code>PhysicsBasedAnimationToolkit_Tests</code>, built by this project. <code>PBAT_ENABLE_PROFILER</code> <code>ON,OFF</code> <code>OFF</code> Enable <code>Tracy</code> instrumentation profiling in built <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code>. <code>PBAT_PROFILE_ON_DEMAND</code> <code>ON,OFF</code> <code>OFF</code> Activate Tracy's on-demand profiling when <code>PBAT_ENABLE_PROFILER</code> is <code>ON</code>. <code>PBAT_USE_INTEL_MKL</code> <code>ON,OFF</code> <code>OFF</code> Link to user-provided Intel MKL installation via CMake's <code>find_package</code>. <code>PBAT_USE_SUITESPARSE</code> <code>ON,OFF</code> <code>OFF</code> Link to user-provided SuiteSparse installation via CMake's <code>find_package</code>. <code>PBAT_BUILD_SHARED_LIBS</code> <code>ON,OFF</code> <code>OFF</code> Build project's library targets as shared/dynamic. <p>Either run CMake's configure step manually <pre><code>cmake -S &lt;path/to/PhysicsBasedAnimationToolkit&gt; -B &lt;path/to/build&gt; -D&lt;option&gt;=&lt;value&gt; ...\n</code></pre> or, alternatively (and preferably) <pre><code>cmake --preset=&lt;my-favorite-user-preset&gt;\n</code></pre></p> <p>Our project provides configuration presets that capture typical use configurations. For the best experience, install <code>vcpkg</code> and set <code>VCPKG_ROOT=path/to/vcpkg</code> as an environment variable. Then, you can select one of our available presets, for example <code>cmake --preset=default</code>. Refer to the CMake presets documentation for more information.</p>"},{"location":"#build-install","title":"Build &amp; Install","text":""},{"location":"#c_1","title":"C++","text":"<p>Build and install transparently across platforms using the cmake build CLI and cmake install CLI, respectively.</p> <p>Our CMake project exposes the following build targets | Target | Description | |---|---| | <code>PhysicsBasedAnimationToolkit_PhysicsBasedAnimationToolkit</code> | The PBA Toolkit library. | | <code>PhysicsBasedAnimationToolkit_Tests</code> | The test executable, using doctest. | | <code>PhysicsBasedAnimationToolkit_Python</code> | PBAT's Python extension module, using pybind11. |</p> <p>For example, to build tests, run <pre><code>cmake --build &lt;path/to/build/folder&gt; --target PhysicsBasedAnimationToolkit_Tests --config Release\n</code></pre></p> <p>To install PhysicsBasedAnimationToolkit locally, run <pre><code>cd path/to/PhysicsBasedAnimationToolkit\ncmake -S . -B build -D&lt;option&gt;=&lt;value&gt; ...\ncmake --install build --config Release\n</code></pre></p>"},{"location":"#python_1","title":"Python","text":"<p>For a local installation, which builds from source, our Python bindings build relies on Scikit-build-core, which relies on CMake's <code>install</code> mechanism. As such, you can configure the installation as you typically would when using the CMake CLI directly, by now passing the corresponding CMake arguments in <code>pip</code>'s <code>config-settings</code> parameter (refer to the Scikit-build-core documentation for the relevant parameters). See our pyinstall workflow for working examples of building from source on Linux, MacOS and Windows. Then, assuming that external dependencies are found via CMake's <code>find_package</code>, you can build and install our Python package <code>pbatoolkit</code> locally and get the most up to date features. </p> <p>Consider using a Python virtual environment for this step.</p> <p>As an example, assuming use of <code>vcpkg</code> for external dependency management with <code>VCPKG_ROOT=path/to/vcpkg</code> set as an environment variable, run</p> <pre><code>pip install . --config-settings=cmake.args=\"--preset=pip-cuda\" -v\n</code></pre> <p>on the command line to build <code>pbatoolkit</code> from source with GPU algorithms included. Additional environment variables (i.e. <code>CUDA_PATH</code>) and/or CMake variables (i.e. <code>CMAKE_CUDA_COMPILER</code>) may be required to be set in order for CMake to correctly discover and compile against your targeted local CUDA installation. Refer to the CMake documentation for more details.</p>"},{"location":"#gallery","title":"Gallery","text":"<p>Below, we show a few examples of what can be done in just a few lines of code using <code>pbatoolkit</code> and Python. Code can be found here.</p>"},{"location":"#real-time-hyper-elasticity-dynamics","title":"Real-time hyper elasticity dynamics","text":"<p>Our GPU implementation of the eXtended Position Based Dynamics (XPBD) algorithm simulates a ~324k element FEM elastic mesh interactively with contact.</p> <p> </p>"},{"location":"#inter-penetration-free-elastodynamic-contact","title":"Inter-penetration free elastodynamic contact","text":"<p>Combining <code>pbatoolkit</code>'s FEM+elasticity features and the <code>IPC Toolkit</code> results in guaranteed inter-penetration free contact dynamics between deformable bodies.</p> <p> </p>"},{"location":"#modal-analysis","title":"Modal analysis","text":"<p>The hyper elastic beam's representative deformation modes, i.e. its low frequency eigen vectors, are animated as time continuous signals.</p> <p> </p>"},{"location":"#gpu-broad-phase-collision-detection","title":"GPU broad phase collision detection","text":"<p>Real-time collision detection between 2 large scale meshes (~324k tetrahedra) is accelerated by highly parallel implementations of the sweep and prune algorithm, or linear bounding volume hierarchies.</p> <p> </p>"},{"location":"#harmonic-interpolation","title":"Harmonic interpolation","text":"<p>A smooth (harmonic) function is constructed on Entei, required to evaluate to <code>1</code> on its paws, and <code>0</code> at the top of its tail, using piece-wise linear (left) and quadratic (right) shape functions. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"#heat-method-for-geodesic-distance-computation","title":"Heat method for geodesic distance computation","text":"<p>Approximate geodesic distances are computed from the top center vertex of Metagross by diffusing heat from it (left), and recovering a function whose gradient matches the normalized heat's negative gradient. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"#mesh-smoothing-via-diffusion","title":"Mesh smoothing via diffusion","text":"<p>Fine details of Godzilla's skin are smoothed out by diffusing <code>x,y,z</code> coordinates in time.</p> <p> </p>"},{"location":"#profiling-statistics","title":"Profiling statistics","text":"<p>Computation details are gathered when using <code>pbatoolkit</code> and consulted in the Tracy profiling server GUI.</p> <p> </p>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#coding-style","title":"Coding style","text":"<p>A <code>.clang-format</code> description file is provided in the repository root which should be used to enforce a uniform coding style throughout the code base using the clang-format tool. Recent versions of Visual Studio Code and Visual Studio should come bundled with a <code>clang-format</code> installation. On Unix-like systems, <code>clang-format</code> can be installed using your favorite package manager.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v008-2024-04-22","title":"[v0.0.8] - 2024-04-22","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New VBD (Vertex Block Descent) implementation on the GPU. Currently does not support contacts.</li> <li>Alternative adaptive initialization strategy for VBD, differing from the strategy proposed in the VBD paper.</li> <li>Nested cage generation tool.</li> <li>Compilation of GPU code included in the CI servers within <code>pyinstall.yml</code>.</li> <li>Split PyPI package into <code>pbatoolkit</code> and <code>pbatoolkit-gpu</code> to facilitate easier usage of GPU features.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Upgraded the repository's README for improved aesthetics and better documentation on using GPU features.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul>"},{"location":"changelog/#contributors","title":"Contributors","text":"<ul> <li>@pranavAL made their first contribution in #3.</li> </ul> <p>Full Changelog: v0.0.7...v0.0.8</p>"},{"location":"changelog/#v007-2024-09-18","title":"[v0.0.7] - 2024-09-18","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Incremental Potential Contact (IPC) Python example using <code>pbatoolkit</code> as the elastodynamics engine.</li> <li>Support for optional elastic element Hessian SPD (Symmetric Positive Definite) projections.</li> <li>Parallelized Sweep and Prune GPU implementation for broad phase collision detection.</li> <li>Various C++ utilities for simpler GPU programming (e.g., device buffers, queues, stacks, lists).</li> <li>XPBD (eXtended Position Based Dynamics) implementation on the GPU using stable neo-Hookean constraints and vertex-triangle contact constraints.</li> <li>Parallelized linear BVH (Bounding Volume Hierarchy) data structure on the GPU for broad phase overlap and nearest neighbor queries.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Allow Windows system search paths to be examined for DLL resolution when importing <code>pbatoolkit</code>.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul>"},{"location":"changelog/#contributors_1","title":"Contributors","text":"<ul> <li>@pranavAL</li> </ul> <p>Full Changelog: v0.0.6...v0.0.7</p>"},{"location":"changelog/#v006-2024-07-18","title":"[v0.0.6] - 2024-07-18","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support and tests for optional integration with fast linear solvers (SuiteSparse's Cholmod and Intel MKL's Pardiso). Note: MKL Pardiso is untested and has known errors.</li> <li>Versioned NumPy and SciPy Python dependencies specified in <code>pyproject.toml</code>.</li> <li>Refactored CMake sources to facilitate shared builds, bundle transitive dependencies in Python bindings installation, and expose better CMake configure presets.</li> <li>Enabled on-demand profiling for <code>pbatoolkit</code>.</li> <li>Simplified Python FEM bindings using type erasure to minimize binary size.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.5...v0.0.6</p>"},{"location":"changelog/#v005-2024-07-12","title":"[v0.0.5] - 2024-07-12","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Tutorials on FEM using <code>pbatoolkit</code>.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Exposed more library internals to make Python scripting more flexible (e.g., quadrature points and weights on mesh, shape function gradients).</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.4...v0.0.5</p>"},{"location":"changelog/#v004-2024-07-09","title":"[v0.0.4] - 2024-07-09","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Implemented and tested optional integration with fast linear solvers (SuiteSparse's Cholmod and Intel MKL's Pardiso). Note: MKL Pardiso is untested and has known errors.</li> <li>Specified versioned NumPy and SciPy Python dependencies in <code>pyproject.toml</code>.</li> <li>Refactored CMake sources to facilitate shared builds, bundle transitive dependencies in Python bindings installation, and expose better CMake configure presets.</li> <li>Enabled on-demand profiling for <code>pbatoolkit</code>.</li> <li>Simplified Python FEM bindings using type erasure to minimize binary size.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: v0.0.3...v0.0.4</p>"},{"location":"changelog/#v003-2024-06-26","title":"[v0.0.3] - 2024-06-26","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Initial release of <code>pbatoolkit</code> with the following features:</li> <li>FEM utilities (mass matrix, Laplacian, gradient, hyperelastic potential, load) for meshes in dimensions 1, 2, and 3. Supports Lagrange shape functions up to order 3 for line, triangle, quadrilateral, tetrahedral, and hexahedral elements. Note: For non-linear elements such as quads and hexes, shape function gradients and Jacobians may be inaccurate (untested).</li> <li>Efficient sparse matrix construction.</li> <li>Saint-Venant Kirchhoff and Stable Neo-Hookean material models.</li> <li>Axis-aligned Bounding Volume Hierarchies (BVH) for triangles and tetrahedra.</li> <li>Automatic profiling data generation compatible with Tracy.</li> <li>Mostly tested on tetrahedral element meshes; designed to be element-agnostic and dimension-agnostic.</li> <li>Sample code demonstrating the use of <code>pbatoolkit</code> available in the <code>examples</code> folder.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>(No changes in this release)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>(No fixes in this release)</li> </ul> <p>Full Changelog: Initial Release</p>"},{"location":"changelog/#contributors_2","title":"Contributors","text":"<ul> <li>@pranavAL - Made their first contribution in #3.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at zfergus@nyu.edu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#coding-style","title":"Coding Style","text":"<p>A <code>.clang-format</code> description file is provided in the repository root which should be used to enforce a uniform coding style throughout the code base using the clang-format tool. Recent versions of Visual Studio Code and Visual Studio should come bundled with a <code>clang-format</code> installation. On Unix-like systems, <code>clang-format</code> can be installed using your favorite package manager.</p>"},{"location":"gallery/","title":"Gallery","text":"<p>Below, we show a few examples of what can be done in just a few lines of code using <code>pbatoolkit</code> and Python. Code can be found here.</p>"},{"location":"gallery/#real-time-hyper-elasticity-dynamics","title":"Real-time Hyper Elasticity Dynamics","text":"<p>Our GPU implementation of the eXtended Position Based Dynamics (XPBD) algorithm simulates a ~324k element FEM elastic mesh interactively with contact.</p> <p> </p>"},{"location":"gallery/#inter-penetration-free-elastodynamic-contact","title":"Inter-penetration Free Elastodynamic Contact","text":"<p>Combining <code>pbatoolkit</code>\u2019s FEM+elasticity features and the <code>IPC Toolkit</code> results in guaranteed inter-penetration free contact dynamics between deformable bodies.</p> <p> </p>"},{"location":"gallery/#modal-analysis","title":"Modal Analysis","text":"<p>The hyper elastic beam's representative deformation modes, i.e., its low frequency eigen vectors, are animated as time continuous signals.</p> <p> </p>"},{"location":"gallery/#gpu-broad-phase-collision-detection","title":"GPU Broad Phase Collision Detection","text":"<p>Real-time collision detection between 2 large scale meshes (~324k tetrahedra) is accelerated by highly parallel implementations of the sweep and prune algorithm, or linear bounding volume hierarchies.</p> <p> </p>"},{"location":"gallery/#harmonic-interpolation","title":"Harmonic Interpolation","text":"<p>A smooth (harmonic) function is constructed on Entei, required to evaluate to <code>1</code> on its paws, and <code>0</code> at the top of its tail, using piece-wise linear (left) and quadratic (right) shape functions. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"gallery/#heat-method-for-geodesic-distance-computation","title":"Heat Method for Geodesic Distance Computation","text":"<p>Approximate geodesic distances are computed from the top center vertex of Metagross by diffusing heat from it (left), and recovering a function whose gradient matches the normalized heat's negative gradient. Its isolines are displayed as black curves.</p> <p> </p>"},{"location":"gallery/#mesh-smoothing-via-diffusion","title":"Mesh Smoothing via Diffusion","text":"<p>Fine details of Godzilla's skin are smoothed out by diffusing <code>x,y,z</code> coordinates in time.</p> <p> </p>"},{"location":"gallery/#profiling-statistics","title":"Profiling Statistics","text":"<p>Computation details are gathered when using <code>pbatoolkit</code> and consulted in the Tracy profiling server GUI.</p> <p> </p>"},{"location":"license/","title":"License","text":"<p>Boost Software License - Version 1.0 - August 17th, 2003</p> <p>Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the \"Software\") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:</p> <p>The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"course/fem/","title":"The Finite Element Method","text":""},{"location":"course/fem/#introduction","title":"Introduction","text":"<p>The Finite Element Method (FEM) is an approach to discretizing space-dependent continuous problems defined on geometrically \"complex\" domains. As opposed to Finite Differences (FD), which is restricted to regular grid domains, FEM relies on meshing the problem's domain (geometric discretization), describing the problem's solution as a linear combination of piece-wise (i.e., per mesh element) interpolating polynomials (functional discretization), and solving the approximated problem on the mesh. The \"Finite\" in FEM comes from limiting the approximate solution to be spanned by a \"finite-dimensional\" functional basis, i.e., the one spanned by the element-wise interpolating polynomials (the basis functions). The \"Element\" in FEM comes from the polynomials being entirely constructed/defined by the simple geometric primitives composing the mesh, called \"elements\".</p> <p></p> <p>With \\(n=|I|\\), FEM restricts \\(u(X)\\) to the class of functions \\(u(X) = \\sum_{i=1}^{n} u_i \\phi_i(X)\\), i.e., linear combinations of coefficients \\(u_i\\) and basis functions \\(\\phi_i\\) associated with nodes \\(i\\). More compactly, \\(u(X) = \\Phi^T u\\), where \\(u = \\begin{bmatrix}u_1 &amp; \\dots &amp; u_{n} \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\) and \\(\\Phi = \\begin{bmatrix} \\phi_1(X) &amp; \\dots &amp; \\phi_{n}(X) \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\). We say that the basis functions \\(\\phi_i\\) span the function space \\(\\{ \\Phi^T u \\;\\forall\\; u \\in \\mathbb{R}^{n} \\}\\), much like basis vectors \\(v_i\\) span vector spaces \\(V\\). Functions in the FEM function space, i.e., the space spanned by \\(\\phi_i\\), are uniquely represented by their vector of coefficients \\(u\\), much like vectors \\(v = v_1 \\overrightarrow{i} + v_2\\overrightarrow{j} + v_3 \\overrightarrow{k}\\) in \\(\\mathbb{R}^3\\) are uniquely represented by their coefficients \\(\\begin{bmatrix} v_1 &amp; v_2 &amp; v_3 \\end{bmatrix}\\). </p> <p></p> <p>Such a discrete functional representation allows one to accurately map continuous problems from theory onto computers by needing only to store the discrete and finite-dimensional coefficients \\(u\\) and FEM mesh \\((I,E)\\), assuming an appropriate geometric meshing of the problem domain is readily available. Furthermore, the linearity of \\(u(X)\\) w.r.t. \\(\\Phi\\) naturally translates solving FEM-discretized problems into solving matrix equations.</p>"},{"location":"course/fem/introduction/","title":"The Finite Element Method","text":""},{"location":"course/fem/introduction/#introduction","title":"Introduction","text":"<p>The Finite Element Method (FEM) is an approach to discretizing space-dependent continuous problems defined on geometrically \"complex\" domains. As opposed to Finite Differences (FD), which is restricted to regular grid domains, FEM relies on meshing the problem's domain (geometric discretization), describing the problem's solution as a linear combination of piece-wise (i.e., per mesh element) interpolating polynomials (functional discretization), and solving the approximated problem on the mesh. The \"Finite\" in FEM comes from limiting the approximate solution to be spanned by a \"finite-dimensional\" functional basis, i.e., the one spanned by the element-wise interpolating polynomials (the basis functions). The \"Element\" in FEM comes from the polynomials being entirely constructed/defined by the simple geometric primitives composing the mesh, called \"elements\".</p> <p></p> <p>With \\(n=|I|\\), FEM restricts \\(u(X)\\) to the class of functions \\(u(X) = \\sum_{i=1}^{n} u_i \\phi_i(X)\\), i.e., linear combinations of coefficients \\(u_i\\) and basis functions \\(\\phi_i\\) associated with nodes \\(i\\). More compactly, \\(u(X) = \\Phi^T u\\), where \\(u = \\begin{bmatrix}u_1 &amp; \\dots &amp; u_{n} \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\) and \\(\\Phi = \\begin{bmatrix} \\phi_1(X) &amp; \\dots &amp; \\phi_{n}(X) \\end{bmatrix}^T \\in \\mathbb{R}^{n}\\). We say that the basis functions \\(\\phi_i\\) span the function space \\(\\{ \\Phi^T u \\;\\forall\\; u \\in \\mathbb{R}^{n} \\}\\), much like basis vectors \\(v_i\\) span vector spaces \\(V\\). Functions in the FEM function space, i.e., the space spanned by \\(\\phi_i\\), are uniquely represented by their vector of coefficients \\(u\\), much like vectors \\(v = v_1 \\overrightarrow{i} + v_2\\overrightarrow{j} + v_3 \\overrightarrow{k}\\) in \\(\\mathbb{R}^3\\) are uniquely represented by their coefficients \\(\\begin{bmatrix} v_1 &amp; v_2 &amp; v_3 \\end{bmatrix}\\). </p> <p></p> <p>Such a discrete functional representation allows one to accurately map continuous problems from theory onto computers by needing only to store the discrete and finite-dimensional coefficients \\(u\\) and FEM mesh \\((I,E)\\), assuming an appropriate geometric meshing of the problem domain is readily available. Furthermore, the linearity of \\(u(X)\\) w.r.t. \\(\\Phi\\) naturally translates solving FEM-discretized problems into solving matrix equations.</p>"},{"location":"course/fem/introduction/#prerequisites","title":"Prerequisites","text":"<ul> <li>Calculus</li> <li>Linear Algebra</li> <li>Differential equations (optional)</li> </ul>"},{"location":"quick_start/","title":"Quick Start","text":"<p>We recommend downloading the Tracy profiler server to analyze execution of PBAT algorithms, available as precompiled executable. PBAT currently supports Tracy 0.10.</p>"},{"location":"quick_start/#c","title":"C++","text":"<p>Take a look at the unit tests, found in the library's source (<code>.cpp</code> or <code>.cu</code>) files.</p>"},{"location":"quick_start/#python","title":"Python","text":"<p>To download and install from PyPI, run in command line <pre><code>pip install pbatoolkit\n</code></pre></p>"},{"location":"workshop/","title":"Workshops","text":"<ol> <li>pbatoolkit.fem</li> <li>Heat diffusion</li> <li>Harmonic solutions</li> <li>Least squares and Poisson problems</li> <li>Lagrange elements</li> </ol>"}]}